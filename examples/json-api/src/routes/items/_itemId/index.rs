use ic_asset_router::{HttpResponse, RouteContext, StatusCode};
use std::borrow::Cow;

use crate::data;

/// GET /items/:itemId — retrieve a single item by ID.
pub fn get(ctx: RouteContext<Params>) -> HttpResponse<'static> {
    let id: u64 = ctx.params.item_id.parse().unwrap_or(0);
    match data::get_item(id) {
        Some(item) => {
            let body = serde_json::to_string(&item).unwrap();
            HttpResponse::builder()
                .with_status_code(StatusCode::OK)
                .with_headers(vec![(
                    "content-type".to_string(),
                    "application/json".to_string(),
                )])
                .with_body(Cow::<[u8]>::Owned(body.into_bytes()))
                .build()
        }
        None => HttpResponse::builder()
            .with_status_code(StatusCode::NOT_FOUND)
            .with_headers(vec![(
                "content-type".to_string(),
                "application/json".to_string(),
            )])
            .with_body(Cow::<[u8]>::Owned(
                br#"{"error":"item not found"}"#.to_vec(),
            ))
            .build(),
    }
}

/// PUT /items/:itemId — update an existing item.
///
/// Expects `{"name":"..."}`. Returns the updated item.
pub fn put(ctx: RouteContext<Params>) -> HttpResponse<'static> {
    let id: u64 = ctx.params.item_id.parse().unwrap_or(0);
    let input: Result<data::CreateItem, _> = ctx.json();

    match input {
        Ok(update) => match data::update_item(id, update) {
            Some(item) => {
                let body = serde_json::to_string(&item).unwrap();
                HttpResponse::builder()
                    .with_status_code(StatusCode::OK)
                    .with_headers(vec![(
                        "content-type".to_string(),
                        "application/json".to_string(),
                    )])
                    .with_body(Cow::<[u8]>::Owned(body.into_bytes()))
                    .build()
            }
            None => HttpResponse::builder()
                .with_status_code(StatusCode::NOT_FOUND)
                .with_headers(vec![(
                    "content-type".to_string(),
                    "application/json".to_string(),
                )])
                .with_body(Cow::<[u8]>::Owned(
                    br#"{"error":"item not found"}"#.to_vec(),
                ))
                .build(),
        },
        Err(_) => HttpResponse::builder()
            .with_status_code(StatusCode::BAD_REQUEST)
            .with_headers(vec![(
                "content-type".to_string(),
                "application/json".to_string(),
            )])
            .with_body(Cow::<[u8]>::Owned(
                br#"{"error":"invalid JSON body"}"#.to_vec(),
            ))
            .build(),
    }
}

/// DELETE /items/:itemId — delete an item.
pub fn delete(ctx: RouteContext<Params>) -> HttpResponse<'static> {
    let id: u64 = ctx.params.item_id.parse().unwrap_or(0);
    if data::delete_item(id) {
        HttpResponse::builder()
            .with_status_code(StatusCode::OK)
            .with_headers(vec![(
                "content-type".to_string(),
                "application/json".to_string(),
            )])
            .with_body(Cow::<[u8]>::Owned(br#"{"deleted":true}"#.to_vec()))
            .build()
    } else {
        HttpResponse::builder()
            .with_status_code(StatusCode::NOT_FOUND)
            .with_headers(vec![(
                "content-type".to_string(),
                "application/json".to_string(),
            )])
            .with_body(Cow::<[u8]>::Owned(
                br#"{"error":"item not found"}"#.to_vec(),
            ))
            .build()
    }
}

// The `Params` struct is generated by the build script in the parent mod.rs.
// It contains:  pub item_id: String
use super::Params;
