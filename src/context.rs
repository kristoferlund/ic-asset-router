use std::collections::HashMap;

use ic_http_certification::{HeaderField, Method};

/// A type alias for query string parameters parsed from the URL.
pub type QueryParams = HashMap<String, String>;

/// A context object bundling all request data for route handlers.
///
/// Rather than accumulating positional arguments as features grow (params, query
/// strings, method, headers, etc.), handlers receive a single context object.
/// This is extensible — new fields can be added without changing every handler
/// signature.
///
/// The type parameter `P` is the typed params struct generated by the build
/// script for each route. Routes without dynamic segments use `()`.
///
/// The type parameter `S` is the typed search (query string) params struct.
/// Routes that define a `pub struct SearchParams` (implementing
/// `serde::Deserialize`) get the query string deserialized into `ctx.search`.
/// Routes without a `SearchParams` struct default to `S = ()`.
///
/// Untyped query access is always available via `ctx.query` regardless of `S`.
pub struct RouteContext<P, S = ()> {
    /// Typed route parameters extracted from the URL path.
    pub params: P,
    /// Typed search (query string) parameters deserialized from the URL.
    ///
    /// Populated by `serde_urlencoded` when the route defines a `SearchParams`
    /// struct. Defaults to `()` for routes without typed search params.
    pub search: S,
    /// Query string parameters parsed from the URL (untyped, always available).
    pub query: QueryParams,
    /// The HTTP method of the request.
    pub method: Method,
    /// The request headers.
    pub headers: Vec<HeaderField>,
    /// The raw request body bytes.
    pub body: Vec<u8>,
    /// The full request URL.
    pub url: String,
}

/// Parse query string key-value pairs from a URL.
///
/// Extracts the portion after `?` and splits on `&` to produce key-value pairs.
/// Keys and values are URL-decoded. Malformed pairs (missing `=`) are skipped.
///
/// Returns an empty map if there is no query string.
pub fn parse_query(url: &str) -> QueryParams {
    let query_str = match url.split_once('?') {
        Some((_, q)) => q,
        None => return QueryParams::new(),
    };

    // Strip fragment if present (e.g. `?page=1#section`)
    let query_str = query_str.split_once('#').map_or(query_str, |(q, _)| q);

    query_str
        .split('&')
        .filter(|s| !s.is_empty())
        .filter_map(|pair| {
            let (key, value) = pair.split_once('=')?;
            Some((url_decode(key).into_owned(), url_decode(value).into_owned()))
        })
        .collect()
}

/// Minimal percent-decoding for query string keys and values.
///
/// Decodes `%XX` hex sequences and `+` as space. Does not validate UTF-8
/// beyond what `String::from_utf8_lossy` handles.
fn url_decode(input: &str) -> std::borrow::Cow<'_, str> {
    if !input.contains('%') && !input.contains('+') {
        return std::borrow::Cow::Borrowed(input);
    }

    let mut bytes = Vec::with_capacity(input.len());
    let mut chars = input.bytes();
    while let Some(b) = chars.next() {
        match b {
            b'+' => bytes.push(b' '),
            b'%' => {
                let hi = chars.next().and_then(|c| hex_val(c));
                let lo = chars.next().and_then(|c| hex_val(c));
                match (hi, lo) {
                    (Some(h), Some(l)) => bytes.push(h << 4 | l),
                    _ => {
                        // Malformed percent encoding — pass through literally
                        bytes.push(b'%');
                    }
                }
            }
            _ => bytes.push(b),
        }
    }

    String::from_utf8(bytes)
        .map(std::borrow::Cow::Owned)
        .unwrap_or_else(|e| String::from_utf8_lossy(e.as_bytes().to_vec().leak()).into())
}

/// Deserialize a URL query string into a typed struct using `serde_urlencoded`.
///
/// This is the helper used by the generated route wiring to populate
/// `RouteContext.search`. If deserialization fails (missing required fields,
/// type mismatches, malformed encoding), returns `S::default()` so that
/// handlers never see a panic from bad query strings.
///
/// The type `S` must implement both `serde::Deserialize` and `Default`.
pub fn deserialize_search_params<S>(query_str: &str) -> S
where
    S: serde::de::DeserializeOwned + Default,
{
    // Strip leading '?' if present (the caller may pass the raw query portion
    // or the full `?key=val` string).
    let qs = query_str.strip_prefix('?').unwrap_or(query_str);
    serde_urlencoded::from_str(qs).unwrap_or_default()
}

fn hex_val(b: u8) -> Option<u8> {
    match b {
        b'0'..=b'9' => Some(b - b'0'),
        b'a'..=b'f' => Some(b - b'a' + 10),
        b'A'..=b'F' => Some(b - b'A' + 10),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_query_basic() {
        let q = parse_query("http://example.com/path?page=3&filter=active");
        assert_eq!(q.get("page").unwrap(), "3");
        assert_eq!(q.get("filter").unwrap(), "active");
    }

    #[test]
    fn parse_query_empty_url() {
        let q = parse_query("");
        assert!(q.is_empty());
    }

    #[test]
    fn parse_query_no_query_string() {
        let q = parse_query("/path/to/resource");
        assert!(q.is_empty());
    }

    #[test]
    fn parse_query_empty_query_string() {
        let q = parse_query("/path?");
        assert!(q.is_empty());
    }

    #[test]
    fn parse_query_with_fragment() {
        let q = parse_query("/path?page=1#section");
        assert_eq!(q.get("page").unwrap(), "1");
        assert_eq!(q.len(), 1);
    }

    #[test]
    fn parse_query_url_encoded_values() {
        let q = parse_query("/search?q=hello+world&name=foo%20bar");
        assert_eq!(q.get("q").unwrap(), "hello world");
        assert_eq!(q.get("name").unwrap(), "foo bar");
    }

    #[test]
    fn parse_query_skips_malformed_pairs() {
        // Pairs without `=` are skipped
        let q = parse_query("/path?good=yes&bad&also=fine");
        assert_eq!(q.get("good").unwrap(), "yes");
        assert_eq!(q.get("also").unwrap(), "fine");
        assert_eq!(q.len(), 2);
    }

    #[test]
    fn parse_query_empty_value() {
        let q = parse_query("/path?key=");
        assert_eq!(q.get("key").unwrap(), "");
    }

    #[test]
    fn parse_query_multiple_equals() {
        // Only splits on the first `=`
        let q = parse_query("/path?expr=a=b");
        assert_eq!(q.get("expr").unwrap(), "a=b");
    }

    // --- 5.3.5: parse_query with valid params (bare query string) ---

    #[test]
    fn parse_query_bare_query_string() {
        // Tests the specific input `?page=3&filter=active` — note: parse_query
        // expects a URL (or URL path), so `?page=3&filter=active` works since
        // it splits on `?`.
        let q = parse_query("?page=3&filter=active");
        assert_eq!(q.get("page").unwrap(), "3");
        assert_eq!(q.get("filter").unwrap(), "active");
    }

    // --- 5.3.6: parse_query with empty string ---

    #[test]
    fn parse_query_empty_string_returns_empty_hashmap() {
        let q = parse_query("");
        assert!(q.is_empty());
    }

    // --- 5.3.7: malformed query values don't panic (typed search params) ---

    #[test]
    fn deserialize_search_params_valid() {
        #[derive(serde::Deserialize, Default, Debug)]
        struct Sp {
            page: Option<u32>,
            filter: Option<String>,
        }

        let sp: Sp = deserialize_search_params("page=3&filter=active");
        assert_eq!(sp.page, Some(3));
        assert_eq!(sp.filter.as_deref(), Some("active"));
    }

    #[test]
    fn deserialize_search_params_type_mismatch_falls_back() {
        // `page=abc` can't parse as u32 — the entire deserialization fails and
        // falls back to Default, giving None for all fields.
        #[derive(serde::Deserialize, Default, Debug)]
        struct Sp {
            page: Option<u32>,
            filter: Option<String>,
        }

        let sp: Sp = deserialize_search_params("page=abc&filter=active");
        // serde_urlencoded fails the whole parse on type mismatch, so we get defaults.
        assert_eq!(sp.page, None);
        assert_eq!(sp.filter, None);
    }

    #[test]
    fn deserialize_search_params_empty_string() {
        #[derive(serde::Deserialize, Default, Debug)]
        struct Sp {
            page: Option<u32>,
        }

        let sp: Sp = deserialize_search_params("");
        assert_eq!(sp.page, None);
    }

    #[test]
    fn deserialize_search_params_missing_fields_default_to_none() {
        #[derive(serde::Deserialize, Default, Debug)]
        struct Sp {
            page: Option<u32>,
            filter: Option<String>,
            limit: Option<u32>,
        }

        let sp: Sp = deserialize_search_params("page=5");
        assert_eq!(sp.page, Some(5));
        assert_eq!(sp.filter, None);
        assert_eq!(sp.limit, None);
    }

    #[test]
    fn deserialize_search_params_with_leading_question_mark() {
        #[derive(serde::Deserialize, Default, Debug)]
        struct Sp {
            page: Option<u32>,
        }

        let sp: Sp = deserialize_search_params("?page=7");
        assert_eq!(sp.page, Some(7));
    }

    #[test]
    fn deserialize_search_params_malformed_encoding_does_not_panic() {
        #[derive(serde::Deserialize, Default, Debug)]
        struct Sp {
            q: Option<String>,
        }

        // Malformed percent encoding — should not panic, falls back to default.
        let sp: Sp = deserialize_search_params("q=%ZZ");
        // serde_urlencoded may handle this gracefully or fail; either way, no panic.
        let _ = sp.q;
    }
}
