use std::collections::HashMap;

use ic_http_certification::{HeaderField, Method};

/// A type alias for query string parameters parsed from the URL.
pub type QueryParams = HashMap<String, String>;

/// A context object bundling all request data for route handlers.
///
/// Rather than accumulating positional arguments as features grow (params, query
/// strings, method, headers, etc.), handlers receive a single context object.
/// This is extensible — new fields can be added without changing every handler
/// signature.
///
/// The type parameter `P` is the typed params struct generated by the build
/// script for each route. Routes without dynamic segments use `()`.
pub struct RouteContext<P> {
    /// Typed route parameters extracted from the URL path.
    pub params: P,
    /// Query string parameters parsed from the URL.
    pub query: QueryParams,
    /// The HTTP method of the request.
    pub method: Method,
    /// The request headers.
    pub headers: Vec<HeaderField>,
    /// The raw request body bytes.
    pub body: Vec<u8>,
    /// The full request URL.
    pub url: String,
}

/// Parse query string key-value pairs from a URL.
///
/// Extracts the portion after `?` and splits on `&` to produce key-value pairs.
/// Keys and values are URL-decoded. Malformed pairs (missing `=`) are skipped.
///
/// Returns an empty map if there is no query string.
pub fn parse_query(url: &str) -> QueryParams {
    let query_str = match url.split_once('?') {
        Some((_, q)) => q,
        None => return QueryParams::new(),
    };

    // Strip fragment if present (e.g. `?page=1#section`)
    let query_str = query_str.split_once('#').map_or(query_str, |(q, _)| q);

    query_str
        .split('&')
        .filter(|s| !s.is_empty())
        .filter_map(|pair| {
            let (key, value) = pair.split_once('=')?;
            Some((url_decode(key).into_owned(), url_decode(value).into_owned()))
        })
        .collect()
}

/// Minimal percent-decoding for query string keys and values.
///
/// Decodes `%XX` hex sequences and `+` as space. Does not validate UTF-8
/// beyond what `String::from_utf8_lossy` handles.
fn url_decode(input: &str) -> std::borrow::Cow<'_, str> {
    if !input.contains('%') && !input.contains('+') {
        return std::borrow::Cow::Borrowed(input);
    }

    let mut bytes = Vec::with_capacity(input.len());
    let mut chars = input.bytes();
    while let Some(b) = chars.next() {
        match b {
            b'+' => bytes.push(b' '),
            b'%' => {
                let hi = chars.next().and_then(|c| hex_val(c));
                let lo = chars.next().and_then(|c| hex_val(c));
                match (hi, lo) {
                    (Some(h), Some(l)) => bytes.push(h << 4 | l),
                    _ => {
                        // Malformed percent encoding — pass through literally
                        bytes.push(b'%');
                    }
                }
            }
            _ => bytes.push(b),
        }
    }

    String::from_utf8(bytes)
        .map(std::borrow::Cow::Owned)
        .unwrap_or_else(|e| String::from_utf8_lossy(e.as_bytes().to_vec().leak()).into())
}

fn hex_val(b: u8) -> Option<u8> {
    match b {
        b'0'..=b'9' => Some(b - b'0'),
        b'a'..=b'f' => Some(b - b'a' + 10),
        b'A'..=b'F' => Some(b - b'A' + 10),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_query_basic() {
        let q = parse_query("http://example.com/path?page=3&filter=active");
        assert_eq!(q.get("page").unwrap(), "3");
        assert_eq!(q.get("filter").unwrap(), "active");
    }

    #[test]
    fn parse_query_empty_url() {
        let q = parse_query("");
        assert!(q.is_empty());
    }

    #[test]
    fn parse_query_no_query_string() {
        let q = parse_query("/path/to/resource");
        assert!(q.is_empty());
    }

    #[test]
    fn parse_query_empty_query_string() {
        let q = parse_query("/path?");
        assert!(q.is_empty());
    }

    #[test]
    fn parse_query_with_fragment() {
        let q = parse_query("/path?page=1#section");
        assert_eq!(q.get("page").unwrap(), "1");
        assert_eq!(q.len(), 1);
    }

    #[test]
    fn parse_query_url_encoded_values() {
        let q = parse_query("/search?q=hello+world&name=foo%20bar");
        assert_eq!(q.get("q").unwrap(), "hello world");
        assert_eq!(q.get("name").unwrap(), "foo bar");
    }

    #[test]
    fn parse_query_skips_malformed_pairs() {
        // Pairs without `=` are skipped
        let q = parse_query("/path?good=yes&bad&also=fine");
        assert_eq!(q.get("good").unwrap(), "yes");
        assert_eq!(q.get("also").unwrap(), "fine");
        assert_eq!(q.len(), 2);
    }

    #[test]
    fn parse_query_empty_value() {
        let q = parse_query("/path?key=");
        assert_eq!(q.get("key").unwrap(), "");
    }

    #[test]
    fn parse_query_multiple_equals() {
        // Only splits on the first `=`
        let q = parse_query("/path?expr=a=b");
        assert_eq!(q.get("expr").unwrap(), "a=b");
    }
}
