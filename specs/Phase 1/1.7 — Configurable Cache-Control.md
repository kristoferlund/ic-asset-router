# 1.7 — Configurable Cache-Control

**Phase:** 1 — Fix Foundations
**Priority:** Medium
**Status:** Not started

## Problem

Cache-Control values are hardcoded in two places:

1. **Static assets** (`src/assets.rs`): `"public, max-age=31536000, immutable"` — applied to all static assets unconditionally. This is correct for content-hashed filenames (e.g., `app.a1b2c3.js`) but wrong for non-hashed files (e.g., `index.html`, `favicon.ico`) which should use a shorter TTL or `no-cache` to allow updates.

2. **Dynamic assets** (`src/lib.rs`): `"public, no-cache, no-store"` — applied to all dynamically generated responses. This is overly aggressive for content that changes rarely (e.g., meta tags for a published blog post could be cached for hours).

There is no way for consumers to configure these values globally or per-route.

## Objective

Make Cache-Control configurable at the global level (separate defaults for static and dynamic assets) and allow per-route overrides.

## Specification

### CacheControl Configuration

```rust
pub struct CacheControl {
    /// Cache-Control for static assets embedded via `include_dir`.
    /// Default: `"public, max-age=31536000, immutable"`
    pub static_assets: String,

    /// Cache-Control for dynamically generated assets.
    /// Default: `"public, no-cache, no-store"`
    pub dynamic_assets: String,
}

impl Default for CacheControl {
    fn default() -> Self {
        Self {
            static_assets: "public, max-age=31536000, immutable".into(),
            dynamic_assets: "public, no-cache, no-store".into(),
        }
    }
}
```

### Integration with AssetConfig

`CacheControl` is added to the existing `AssetConfig` from spec 1.1:

```rust
pub struct AssetConfig {
    pub security_headers: SecurityHeaders,
    pub cache_control: CacheControl,
    pub custom_headers: Vec<HeaderField>,
}
```

### Per-Route Override

Handlers can override Cache-Control via the response headers (spec 1.2 `DynamicResponse::headers`) or via the `#[route]` attribute (spec 5.1):

```rust
#[route(cache_control = "public, max-age=3600")]
pub fn get(ctx: RouteContext<Params>) -> DynamicResponse {
    // ...
}
```

Per-route Cache-Control overrides the global `dynamic_assets` default.

### Static Asset Nuance

The `static_assets` default of `immutable` assumes content-hashed filenames. For files like `index.html` that are not content-hashed, the consumer should either:

- Set a different global default and override per-file
- Or (more practically) rely on the SPA fallback mechanism (spec 3.1) which serves `index.html` dynamically, making it subject to the `dynamic_assets` cache policy instead

This is documented guidance, not a library enforcement.

### Relationship to TTL-Based Cache Invalidation (4.1)

`Cache-Control` is an **HTTP header** — it tells browsers and CDNs how long to cache a response. TTL (spec 4.1) is an **internal library mechanism** — it controls when the library regenerates a cached dynamic asset. They are complementary:

- `Cache-Control` controls **client-side** caching (browser, CDN, proxy)
- TTL controls **server-side** caching (within the canister's asset router)

Both can be configured independently.

## Files to Modify

- `src/assets.rs` — Replace hardcoded cache-control strings with values from `CacheControl` config
- `src/lib.rs` — Use `CacheControl::dynamic_assets` when certifying dynamic responses
- `src/config.rs` — Add `CacheControl` struct (same file as `SecurityHeaders` from spec 1.1)

## Acceptance Criteria

- [ ] No hardcoded Cache-Control strings remain in the codebase
- [ ] `CacheControl::default()` reproduces current behavior (`immutable` for static, `no-cache, no-store` for dynamic)
- [ ] Global `static_assets` and `dynamic_assets` defaults can be overridden at initialization
- [ ] Per-route Cache-Control override works via handler response headers
- [ ] Cache-Control and TTL (spec 4.1) are documented as independent, complementary mechanisms
