# 2.2 — Middleware System

**Phase:** 2 — Method Routing & Middleware
**Priority:** High
**Status:** Not started

## Problem

No pre-processing or post-processing of requests exists. Auth checks, logging, CORS handling, response header injection — all must be duplicated inside each handler or wrapped around the top-level `http_request` / `http_request_update` functions manually.

## Objective

Implement a middleware chain that can inspect/modify requests before they reach the handler and inspect/modify responses after.

## Specification

### Middleware Signature

```rust
pub type MiddlewareFn = fn(
    req: HttpRequest,
    params: &RouteParams,
    next: &dyn Fn(HttpRequest, &RouteParams) -> HttpResponse<'static>,
) -> HttpResponse<'static>;
```

A middleware can:
- Inspect/modify the request before calling `next`
- Short-circuit by returning a response without calling `next` (e.g., auth rejection)
- Inspect/modify the response after calling `next`

### Design Principle

The programmatic API is the foundation. File-based routing is syntactic sugar — the code generator produces programmatic calls. Both APIs must support the same capabilities.

### One Middleware Per Level

Following Next.js and TanStack Router conventions: **one middleware per scope level**. No stacking multiple middleware at the same level — it eliminates ordering ambiguity.

- **Root level** — Runs on every request
- **Directory level** — Runs on all routes in that directory and its children

Execution order: Root → outer directory → inner directory → handler → inner → outer → root

### Programmatic API (Foundation)

```rust
router.set_middleware("/", root_middleware);         // global — runs on all routes
router.set_middleware("/api", auth_middleware);      // scoped — runs on /api/* routes
```

One middleware per prefix. Calling `use_middleware` on the same prefix replaces the previous one (no stacking).

### File Convention (Sugar)

A `middleware.rs` file in a directory applies to all routes in that directory and its children:

```
src/routes/
  middleware.rs          → router.use_middleware("/", ...)
  api/
    middleware.rs        → router.use_middleware("/api", ...)
    users.rs
    posts.rs
  pages/
    index.rs
```

Each `middleware.rs` exports a single function:
```rust
pub fn middleware(
    req: HttpRequest,
    params: &RouteParams,
    next: &dyn Fn(HttpRequest, &RouteParams) -> HttpResponse<'static>,
) -> HttpResponse<'static> {
    // Pre-processing
    let mut response = next(req, params);
    // Post-processing
    response
}
```

The code generator detects `middleware.rs` files and emits the corresponding `router.set_middleware(...)` calls.

### Common Middleware Examples

**CORS:**
```rust
pub fn middleware(req, params, next) -> HttpResponse {
    if req.method() == Method::OPTIONS {
        return preflight_response();
    }
    let mut res = next(req, params);
    res.add_header("access-control-allow-origin", "*");
    res
}
```

**Auth check:**
```rust
pub fn middleware(req, params, next) -> HttpResponse {
    match validate_token(&req) {
        Ok(_) => next(req, params),
        Err(_) => error_response(401, "Unauthorized"),
    }
}
```

### Code Generator Changes

`build.rs` must:
1. Detect `middleware.rs` files in the route directory tree
2. Register them at the appropriate scope level
3. Build the middleware chain in the correct nesting order

## Files to Modify

- `src/router.rs` — Add middleware storage and chain execution
- `src/build.rs` — Detect `middleware.rs` files, generate registration code
- `src/lib.rs` — Execute middleware chain before/after handler in both query and update paths
- New: `src/middleware.rs` — Types and chain execution logic

## Acceptance Criteria

- [ ] Programmatic API: `router.set_middleware(prefix, fn)` works correctly
- [ ] One middleware per scope level — second registration on same prefix replaces first
- [ ] Directory-scoped middleware runs only on routes in that directory and children
- [ ] Chain executes in correct order (root → outer → inner → handler → inner → outer → root)
- [ ] Middleware can short-circuit (return response without calling next)
- [ ] Middleware can modify both request and response
- [ ] File convention (`middleware.rs`) generates correct programmatic calls
- [ ] Middleware works in both query and update call paths
- [ ] Tests cover: ordering, short-circuit, nesting, modification, both call paths
