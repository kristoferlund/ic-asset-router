# 3.1 — Template Engine & HTMX Examples

**Phase:** 3 — SSR & Template Integration
**Priority:** Medium
**Status:** Not started

## Problem

The asset router supports full server-side rendering -- handlers can generate and return arbitrary HTML. But there is no guidance or example code showing how to wire up template engines (Askama, Tera) or how to build an HTMX-driven canister application. Each developer must figure out the patterns from scratch.

## Objective

Provide concrete, working integration examples that demonstrate the SSR use case:
1. Askama (compile-time templates) integration pattern
2. Tera (runtime templates) integration pattern
3. A complete HTMX example canister

The library itself does not need template-specific code. The handler API is already flexible enough -- handlers return `HttpResponse`, which can contain any HTML however it was generated. The value here is documentation and a reference implementation.

## Specification

### Askama Integration Pattern

Askama is the most natural fit for ICP canisters -- templates are compiled into Rust code at build time, so there is no runtime template parsing overhead and no filesystem access needed (which WASM canisters don't have).

```rust
use askama::Template;

#[derive(Template)]
#[template(path = "post.html")]
struct PostTemplate<'a> {
    title: &'a str,
    content: &'a str,
    author: &'a str,
}

pub fn get(req: HttpRequest, params: RouteParams) -> HttpResponse<'static> {
    let post_id = params.get("postId").unwrap();
    let post = load_post(post_id);

    let template = PostTemplate {
        title: &post.title,
        content: &post.content,
        author: &post.author,
    };

    HttpResponse::builder()
        .with_status_code(200)
        .with_body(template.render().unwrap().into_bytes())
        .with_headers(vec![("content-type".into(), "text/html; charset=utf-8".into())])
        .build()
}
```

Key points for documentation:
- Templates live in a `templates/` directory and are embedded at compile time
- `askama` must be added as a dependency in the consumer's `Cargo.toml`
- Template rendering errors should be handled gracefully (not `.unwrap()` in production)
- The `content-type` header must be set by the handler (spec 1.2 ensures the library respects it through certification)

### Tera Integration Pattern

Tera uses runtime templates. In the canister context, templates must be embedded via `include_str!` at compile time and loaded into the Tera engine during canister initialization, since canisters have no filesystem.

```rust
use tera::{Tera, Context};
use std::cell::RefCell;

thread_local! {
    static TERA: RefCell<Tera> = RefCell::new({
        let mut tera = Tera::default();
        tera.add_raw_template("post.html", include_str!("../templates/post.html")).unwrap();
        tera.add_raw_template("layout.html", include_str!("../templates/layout.html")).unwrap();
        tera
    });
}

pub fn get(req: HttpRequest, params: RouteParams) -> HttpResponse<'static> {
    let post_id = params.get("postId").unwrap();
    let post = load_post(post_id);

    let mut context = Context::new();
    context.insert("title", &post.title);
    context.insert("content", &post.content);

    let html = TERA.with(|t| t.borrow().render("post.html", &context).unwrap());

    HttpResponse::builder()
        .with_status_code(200)
        .with_body(html.into_bytes())
        .with_headers(vec![("content-type".into(), "text/html; charset=utf-8".into())])
        .build()
}
```

Key points for documentation:
- Templates must be loaded via `include_str!` -- no filesystem at runtime
- Tera supports template inheritance (`{% extends "layout.html" %}`) which is useful for consistent page layouts
- The `thread_local!` pattern is standard for ICP canister state
- Tera adds runtime overhead (template parsing at init) but offers more flexibility (template inheritance, filters, macros)

### Askama vs Tera -- Guidance

| Aspect | Askama | Tera |
|--------|--------|------|
| Template compilation | Build time | Runtime (at init) |
| Type safety | Full (compile errors for missing vars) | None (runtime errors) |
| Template inheritance | Limited (blocks, includes) | Full (extends, blocks, macros) |
| WASM binary size | Smaller (no parser) | Larger (includes parser) |
| Flexibility | Templates fixed at compile time | Templates can be loaded dynamically |
| Recommendation | Default choice for most canisters | Use when you need template inheritance or dynamic templates |

### HTMX Example Canister

A complete example canister demonstrating the full SSR use case with HTMX. This is the "olden days" pattern -- no React, no SPA, all HTML generated server-side with interactive updates via HTMX partial responses.

The example should demonstrate:

1. **Page routes** -- Full HTML pages with layout (header, nav, content, footer)
2. **Partial routes** -- HTMX-targeted endpoints returning HTML fragments (e.g., a list that updates without full page reload)
3. **Dynamic parameters** -- Routes like `/posts/:postId` rendering a specific post
4. **Template engine** -- Askama for compile-time safety
5. **Static assets** -- CSS, maybe a small JS file for HTMX itself (served via the library's static asset pipeline)

Proposed route structure:
```
examples/htmx-app/
  src/
    routes/
      index.rs          -- GET / → full page with post list
      posts/
        _postId.rs      -- GET /posts/:postId → full post page
        _postId/
          comments.rs   -- GET /posts/:postId/comments → HTMX partial (comments list)
    templates/
      layout.html       -- Base layout (head, nav, footer)
      index.html        -- Post list page
      post.html         -- Single post page
      partials/
        comments.html   -- Comments fragment (no layout, just the list)
  static/
    htmx.min.js         -- HTMX library
    style.css           -- Basic styling
  Cargo.toml
  dfx.json              -- ICP project config
```

The example should be minimal but functional -- enough to demonstrate the pattern, not a production app.

## Dependencies

- Spec 1.2 (Handler-Controlled Response Metadata) must be complete -- handlers set `content-type` and the library respects it through certification
- The example canister uses the Phase 5 naming conventions (`_postId` instead of `:postId`) if Phase 5 is complete by then; otherwise uses the current convention

## Deliverables

- `examples/htmx-app/` -- Complete, compilable example canister
- Documentation section in README or docs showing Askama and Tera integration patterns
- Documentation comparing Askama vs Tera for the canister context

## Acceptance Criteria

- [ ] Askama integration pattern is documented with a complete, working example
- [ ] Tera integration pattern is documented with a complete, working example
- [ ] Comparison table helps developers choose between Askama and Tera
- [ ] HTMX example canister exists in `examples/htmx-app/`
- [ ] Example canister compiles (`cargo build --target wasm32-unknown-unknown`)
- [ ] Example demonstrates full pages, HTMX partials, and dynamic route parameters
- [ ] Example serves static assets (HTMX JS, CSS) alongside dynamic routes
- [ ] Content-type headers are correctly set and certified for all responses
