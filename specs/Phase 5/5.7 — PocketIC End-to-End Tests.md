# 5.7 — PocketIC End-to-End Tests

**Phase:** 5 — Developer Experience & Tooling
**Priority:** High
**Status:** Not started

## Problem

Unit tests (spec 5.5) can verify routing logic, config, and code generation in isolation, but they cannot test the full ICP HTTP pipeline: the query→upgrade→update flow, response certification, certified data headers, the interaction between static and dynamic assets, or cache behavior under real canister execution. These are the behaviors that matter most for correctness and are the hardest to get right.

Testing against a real canister requires either deploying to a testnet (slow, non-deterministic) or using a local canister execution environment. PocketIC provides exactly this — a lightweight, deterministic, in-process IC replica that can be driven from Rust test code.

## Objective

Build an end-to-end test suite using PocketIC that deploys a test canister and validates the full HTTP request lifecycle through real canister execution.

## PocketIC Overview

[PocketIC](https://github.com/dfinity/pocketic) is a canister testing solution for the Internet Computer:

- **Deterministic** — Synchronous control over the IC execution environment
- **Lightweight** — Mocks consensus and networking layers
- **Rust-native** — The `pocket-ic` crate provides a Rust API for creating IC instances, deploying canisters, and making calls
- **HTTP gateway** — `PocketIc::make_live()` creates a local HTTP gateway, enabling real HTTP requests to the canister via `reqwest` or similar

Key API methods:
- `PocketIc::new()` — Create an IC instance
- `pic.create_canister()` / `pic.install_canister()` — Deploy a canister
- `pic.make_live(None)` — Start HTTP gateway on localhost (returns URL)
- `pic.query_call()` / `pic.update_call()` — Call canister methods directly
- `pic.tick()` — Advance the IC by one block
- `pic.set_time()` / `pic.advance_time()` — Control canister time (useful for TTL testing)

## Specification

### Test Canister

A dedicated test canister that exercises the router library's features with known, predictable behavior. This is not an example for users — it's a test fixture.

```
tests/
  e2e/
    test_canister/
      src/
        lib.rs              -- Canister entry point, routes registered
        routes/
          index.rs          -- GET / → returns "hello" as text/html
          json.rs           -- GET /json → returns {"ok":true} as application/json
          echo/
            _path.rs        -- GET /echo/:path → returns the path param as text
          posts/
            _postId.rs      -- GET /posts/:postId → returns HTML with post ID
          files/
            all.rs          -- GET /files/* → returns the wildcard capture
          method_test.rs    -- GET returns "get", POST returns "post"
        not_found.rs        -- Custom 404 → returns "custom 404: <path>"
        middleware.rs       -- Adds X-Test-Middleware header to all responses
      templates/            -- (if Askama tests needed)
      static/
        style.css           -- A known static file for static asset tests
      Cargo.toml
    Cargo.toml              -- Workspace or standalone test crate depending on pocket-ic, reqwest
    src/
      lib.rs                -- Test module(s)
```

### Test Scenarios

Each scenario is a `#[test]` function that creates a PocketIC instance, deploys the test canister, starts the HTTP gateway, and makes HTTP requests.

#### Static Asset Serving
- GET `/style.css` → 200, body matches the embedded file content, `content-type: text/css`, cache-control matches configured static value, certification headers present (`IC-Certificate`)

#### Dynamic Route — First Request (Query→Update Flow)
- GET `/` → first request triggers update call (query finds no cached response, returns upgrade, update generates and certifies), response body is "hello", `content-type: text/html`

#### Dynamic Route — Cached Response
- GET `/` again → served from cache (no update call), same response, certification headers present

#### Dynamic Parameter Extraction
- GET `/posts/42` → response body contains "42"
- GET `/echo/some-value` → response body is "some-value"

#### Wildcard Capture
- GET `/files/docs/2024/report.pdf` → response body contains "docs/2024/report.pdf"

#### JSON Content-Type
- GET `/json` → response has `content-type: application/json`, body is `{"ok":true}`, certification metadata uses JSON content-type (not hardcoded HTML)

#### HTTP Method Dispatch
- GET `/method_test` → response body is "get"
- POST `/method_test` → response body is "post"
- PUT `/method_test` → 405 Method Not Allowed (if not implemented)

#### Security Headers
- Any response → includes the configured security headers (check for `strict-transport-security`, `x-content-type-options`, etc.)

#### Custom 404
- GET `/nonexistent` → response body contains "custom 404", status 404

#### Middleware
- Any response → includes `X-Test-Middleware` header (set by the middleware)

#### Cache Invalidation (if Phase 4 complete)
- GET `/posts/42` → response cached
- Call `invalidate_path("/posts/42")` via update call
- GET `/posts/42` → triggers regeneration (not cache hit)

#### TTL Expiry (if Phase 4 complete)
- GET a route with TTL configured → cached
- `pic.advance_time(ttl + 1 second)` + `pic.tick()`
- GET again → triggers regeneration (TTL expired)

### PocketIC Setup

```rust
use pocket_ic::PocketIc;
use reqwest::blocking::Client;

fn setup() -> (PocketIc, String) {
    let pic = PocketIc::new();
    let canister_id = pic.create_canister();
    pic.add_cycles(canister_id, 2_000_000_000_000);

    let wasm = std::fs::read("path/to/test_canister.wasm").expect("test canister wasm");
    pic.install_canister(canister_id, wasm, vec![], None);

    let url = pic.make_live(None);
    let base_url = format!("http://{}/?canisterId={}", url, canister_id);
    (pic, base_url)
}

#[test]
fn test_static_asset_serving() {
    let (pic, base_url) = setup();
    let client = Client::new();
    let resp = client.get(format!("{}/style.css", base_url)).send().unwrap();
    assert_eq!(resp.status(), 200);
    assert!(resp.headers().get("content-type").unwrap().to_str().unwrap().contains("text/css"));
    // Check certification header present
    assert!(resp.headers().get("IC-Certificate").is_some());
    drop(pic); // stops the HTTP gateway
}
```

The exact URL format for the HTTP gateway may need adjustment based on PocketIC's routing (canister ID in the URL vs subdomain). This should be determined during implementation.

### Build Integration

The test canister must be compiled to WASM before the E2E tests can run. Options:

1. **Build script** — A `build.rs` in the test crate that compiles the test canister
2. **Makefile/shell script** — `cargo build --target wasm32-unknown-unknown -p test_canister && cargo test -p e2e-tests`
3. **CI step** — Build the canister WASM in a prior CI step, E2E tests read the artifact

Option 2 is the simplest. Document the two-step process.

### PocketIC Server Binary

The `pocket-ic` crate requires the PocketIC server binary. Options:

1. `POCKET_IC_BIN` environment variable pointing to the binary
2. Download automatically in CI via the PocketIC GitHub Action

Document both approaches.

## Dependencies

- Spec 5.5 (unit tests) should be complete first — ensures the logic is correct before testing integration
- Phase 1 must be complete (the library needs to be functional)
- Phase 4 (cache invalidation, TTL) is optional — TTL-related tests can be added later

## Files to Create

- `tests/e2e/test_canister/` — Complete test canister (Cargo.toml, src/, static/)
- `tests/e2e/Cargo.toml` — Test crate depending on `pocket-ic`, `reqwest`
- `tests/e2e/src/lib.rs` — Test functions
- `tests/e2e/build_and_test.sh` — Script to build test canister WASM and run tests

## Acceptance Criteria

- [ ] PocketIC server binary documented (download instructions, env var)
- [ ] Test canister compiles to WASM (`cargo build --target wasm32-unknown-unknown`)
- [ ] Test canister deploys to PocketIC and responds to HTTP requests
- [ ] Static asset serving test passes (correct MIME, headers, certification)
- [ ] Dynamic route first-request test passes (query→update flow)
- [ ] Dynamic route cached response test passes
- [ ] Parameter extraction test passes
- [ ] Wildcard capture test passes
- [ ] JSON content-type test passes (certification uses correct content-type)
- [ ] HTTP method dispatch test passes (GET, POST, 405)
- [ ] Security headers test passes
- [ ] Custom 404 test passes
- [ ] Middleware test passes
- [ ] Cache invalidation test passes (if Phase 4 complete)
- [ ] TTL expiry test passes (if Phase 4 complete)
- [ ] All E2E tests can be run with a single command
- [ ] CI integration documented
