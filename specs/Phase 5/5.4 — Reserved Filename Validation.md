# 5.4 — Reserved Filename Validation

**Phase:** 5 — Developer Experience & Tooling
**Priority:** Medium
**Status:** Not started

## Problem

The file-based routing convention reserves certain filenames for special purposes:

| Reserved file | Purpose | Expected export |
|---------------|---------|-----------------|
| `middleware.rs` | Middleware function for the directory and its children | Middleware signature (not a route handler) |
| `not_found.rs` | Custom 404 handler for unmatched routes | 404 handler signature (not a regular route) |
| `all.rs` | Catch-all wildcard handler (`/*`) | Regular handler (no special signature) |
| `index.rs` | Handler for the directory's own path | Regular handler (no special signature) |

`all.rs` and `index.rs` are just naming conventions for regular handlers -- they require no special validation. The concerns are with `middleware.rs` and `not_found.rs`:

1. **Misuse as regular handlers** -- A developer might put a regular route handler (`pub fn get(...)`) in `middleware.rs`, expecting it to be registered as a route at `/middleware`. The build script should not silently register it as a route. It should either detect the wrong export signature and produce a compile-time error, or at minimum skip it with a clear warning.

2. **Misuse as middleware** -- A developer might put middleware-shaped code in a non-reserved filename, expecting it to act as middleware. This is less dangerous (it would just be treated as a route and fail at compile time with a type mismatch), but a helpful error message would improve DX.

3. **Name collision** -- A developer might legitimately want a route at the path `/middleware` or `/not_found`. The reserved filename blocks this. There should be a documented escape hatch (e.g., using `#[route(path = "middleware")]` on a differently-named file).

## Objective

Ensure the build script validates reserved filenames at compile time, producing clear error messages when reserved files are misused, and documenting how to work around reserved name collisions.

## Specification

### Build-Time Validation Rules

The build script (`build.rs` / code generator) should enforce:

1. **`middleware.rs` is never registered as a route.** When the build script encounters `middleware.rs` in a directory, it skips route registration for that file entirely. Instead, it generates middleware wiring code that calls the file's middleware export.

2. **`not_found.rs` is never registered as a route.** When the build script encounters `not_found.rs`, it registers the file as the 404 handler for that directory's scope, not as a route for the literal path `/not_found`.

3. **Signature validation (best-effort).** The build script can optionally scan reserved files for expected exports:
   - `middleware.rs` should export a function matching the middleware signature
   - `not_found.rs` should export a handler function
   
   Full signature validation requires parsing Rust source (via `syn` or regex). A lighter approach: check that the file contains `pub fn middleware` (for middleware.rs) or `pub fn handler` / `pub fn get` (for not_found.rs). If the expected export is missing, emit a `cargo:warning=...` message during build.

4. **If validation is too complex for the build script**, rely on the generated code producing a compile error. For example, if `middleware.rs` doesn't export the right type, the generated wiring code that calls it as middleware will fail to compile with a type mismatch. This is acceptable -- the error message may not be ideal, but it prevents silent misuse.

### Reserved Name Collision Escape Hatch

If a developer needs a route at `/middleware` or `/not_found`:

- Use a differently-named file (e.g., `mw.rs`) with a `#[route(path = "middleware")]` attribute
- Or use a directory: `middleware_page/index.rs` which maps to `/middleware_page` (distinct from the reserved `middleware.rs`)

Document this in the routing conventions guide.

### Complete Reserved Filename Registry

Maintain a single source of truth for reserved filenames, used by the build script:

```rust
const RESERVED_FILES: &[&str] = &["middleware", "not_found"];
```

Files not in this list (including `all`, `index`) are treated as regular route handlers. The registry is checked during directory scanning.

### Error Messages

| Scenario | Behavior |
|----------|----------|
| `middleware.rs` exists, exports correct middleware function | Registered as middleware (correct) |
| `middleware.rs` exists, exports a route handler (`pub fn get`) | Build warning: "middleware.rs should export a middleware function, not a route handler" + compile error from generated wiring |
| `not_found.rs` exists, exports a handler | Registered as 404 handler (correct) |
| File named `middleware.rs` in routes dir but developer wants `/middleware` route | Document: use `#[route(path = "middleware")]` on a different file |

## Dependencies

- Spec 5.1 (Build Script & IDE Ergonomics) -- the build script rewrite must be in place before adding validation logic to it
- Spec 2.2 (Middleware System) -- the middleware file convention and expected signature must be defined

## Files to Modify

- `src/build.rs` -- Add reserved filename detection and skip/validation logic during directory scanning
- Documentation -- Document reserved filenames, their purpose, and the escape hatch for name collisions

## Acceptance Criteria

- [ ] `middleware.rs` is never registered as a route handler
- [ ] `not_found.rs` is never registered as a regular route
- [ ] Build produces a warning or error when a reserved file doesn't export the expected signature
- [ ] A developer can create a route at `/middleware` using the `#[route]` escape hatch
- [ ] Reserved filename list is maintained as a single constant in the build script
- [ ] Documentation covers reserved filenames, expected exports, and the escape hatch
