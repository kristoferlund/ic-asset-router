# 5.3 — Query String Access & Typed Search Params

**Phase:** 5 — Developer Experience & Tooling
**Priority:** Medium
**Status:** Not started

## Problem

There is no built-in query string parsing. Handlers that need to read URL query parameters (e.g., `?page=3&filter=active`) must parse the raw URL themselves. This is boilerplate-heavy and error-prone.

## Objective

Provide query string access at two levels: untyped (always available, zero config) and typed (opt-in per route with compile-time safety).

## Specification

### How Other Frameworks Handle Query Strings

| Framework | Approach |
|-----------|----------|
| TanStack Router | `validateSearch` per route with Zod schemas — strictest; validated/typed result before handler runs |
| Hono | `validator('query', schema)` middleware — opt-in per route |
| Next.js | Raw `searchParams: Record<string, string \| string[] \| undefined>` — no validation |
| Express / Actix | Raw `req.query` — no validation, handler's responsibility |

### Recommendation: Typed Deserialization, Not Schema Validation

Full schema validation before the handler (TanStack-style) is likely over-engineered for this context. ICP canisters process one request at a time in single-threaded WASM — there's no concurrency benefit to rejecting bad input early. Domain-level validation (is this a valid email? is this ID in range?) belongs in the handler.

### Level 1: Untyped (Always Available)

`ctx.query` as a `HashMap<String, String>` parsed from the raw query string. Zero configuration, works for any route:

```rust
pub fn get(ctx: RouteContext<Params>) -> HttpResponse<'static> {
    let page = ctx.query.get("page");  // Option<&String>
    let filter = ctx.query.get("filter");
    // ...
}
```

This is provided by the `RouteContext` (see 5.2) with no additional setup needed.

### Level 2: Typed (Opt-In Per Route)

A route can define a `SearchParams` struct. The library deserializes the query string into it before calling the handler. "Validation" is just Rust's type system — missing optional fields become `None`, type mismatches become defaults or errors.

```rust
// src/routes/posts/index.rs
use router_library::RouteContext;
use serde::Deserialize;

#[derive(Deserialize)]
pub struct SearchParams {
    pub page: Option<u32>,        // ?page=3 -> Some(3), missing -> None
    pub filter: Option<String>,   // ?filter=active -> Some("active")
    pub limit: Option<u32>,       // ?limit=abc -> None (failed to parse)
}

pub fn get(ctx: RouteContext<Params, SearchParams>) -> HttpResponse<'static> {
    let page = ctx.search.page.unwrap_or(1);
    let filter = ctx.search.filter.as_deref().unwrap_or("all");
    // ...
}
```

### RouteContext with Search Params Type Parameter

This adds `SearchParams` as a second type parameter on `RouteContext<P, S>`, defaulting to `()` for routes that don't need it:

```rust
pub struct RouteContext<P, S = ()> {
    pub params: P,
    pub search: S,
    pub method: Method,
    pub headers: Vec<HeaderField>,
    pub body: Vec<u8>,
    pub url: String,
}
```

Routes that don't define a `SearchParams` struct use `RouteContext<Params>` (which is `RouteContext<Params, ()>`). The `search` field is `()` and effectively doesn't exist.

### Deserialization Mechanism

The `SearchParams` struct is defined by the developer (not generated), since only the developer knows what query parameters a route expects. It uses `serde::Deserialize` to parse from the query string, leveraging the `serde_urlencoded` crate:

```rust
// In generated wiring
let search: SearchParams = serde_urlencoded::from_str(query_string)
    .unwrap_or_default();
```

### Scope of Validation

Anything beyond type deserialization (email format, value ranges, business rules) is the handler's responsibility. The library provides the parsed data; the handler validates the semantics.

### Dependency

This adds `serde` and `serde_urlencoded` as dependencies (behind a feature flag if needed). Both are widely used in the Rust ecosystem and compile to WASM without issues.

## Files to Modify

- `src/context.rs` — Add `search: S` field to `RouteContext<P, S>`, default `S = ()`
- `src/build.rs` — Detect `SearchParams` type in route files; generate wiring that deserializes query string
- `Cargo.toml` — Add `serde_urlencoded` dependency (possibly behind a feature flag)

## Acceptance Criteria

- [ ] `ctx.query` provides `HashMap<String, String>` for all routes with no configuration
- [ ] Routes can define a `SearchParams` struct with `serde::Deserialize`
- [ ] `ctx.search` is populated by deserializing the query string into `SearchParams`
- [ ] Missing optional fields default to `None`
- [ ] Type mismatches (e.g., `?page=abc` for `Option<u32>`) result in `None`, not a panic
- [ ] Routes without `SearchParams` use `RouteContext<Params>` (second type param defaults to `()`)
- [ ] `serde_urlencoded` is used for deserialization
- [ ] No schema validation beyond type deserialization — business logic is the handler's job
