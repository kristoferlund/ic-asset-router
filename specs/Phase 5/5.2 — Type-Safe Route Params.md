# 5.2 — Type-Safe Route Params

**Phase:** 5 — Developer Experience & Tooling
**Priority:** High
**Status:** Not started

## Problem

Route params are `HashMap<String, String>` — there's no IDE completion, typos cause runtime panics, and the handler signature gives no indication of what parameters are available:

```rust
// Current: untyped, error-prone
pub fn get(req: HttpRequest, params: RouteParams) -> HttpResponse<'static> {
    let post_id = params.get("postId").unwrap(); // no completion, typo = runtime panic
}
```

Additionally, the handler signature `(HttpRequest, RouteParams)` doesn't scale well. As the library adds features (query strings, method access, headers), adding more positional arguments to every handler becomes unwieldy.

## Objective

Generate typed `Params` structs per route and introduce a `RouteContext<P>` that bundles all request data, giving full IDE completion and compile-time checking.

## Specification

### RouteContext — A Single Context Object

Rather than accumulating positional arguments as features grow (params, query strings, method, headers, etc.), handlers receive a single context object. This is the pattern used by Axum (`State`, extractors), Actix (`HttpRequest`, `web::Path`), Hono (`c`), Express (`req`), and Next.js route handlers (`request`, `context`). A context object is extensible — new fields can be added without changing every handler signature.

```rust
// Provided by the library
pub struct RouteContext<P> {
    pub params: P,
    pub query: QueryParams,
    pub method: Method,
    pub headers: Vec<HeaderField>,
    pub body: Vec<u8>,
    pub url: String,
}

pub type QueryParams = HashMap<String, String>;
```

### Generated Params Structs

The build script knows which path segments are dynamic parameters for each route. It generates a typed `Params` struct per route:

For the route `/posts/:postId/edit` (file `src/routes/posts/_postId/edit.rs`), the build script generates:

```rust
// Generated into the route module
pub struct Params {
    pub post_id: String,
}
```

### Handler Usage

```rust
// src/routes/posts/_postId/edit.rs
use crate::routes::posts::_postId::Params;
use router_library::RouteContext;

pub fn get(ctx: RouteContext<Params>) -> HttpResponse<'static> {
    let post_id = &ctx.params.post_id;  // typed, IDE completion works
    let page = ctx.query.get("page");   // query string access
    // ...
}
```

### Generated Route Tree Wiring

The generated wiring constructs the context before calling the handler:

```rust
// Generated wiring (in __route_tree.rs)
root.insert("/posts/:postId/edit", |req, raw_params| {
    let ctx = RouteContext {
        params: routes::posts::_postId::Params {
            post_id: raw_params.get("postId").unwrap().clone(),
        },
        query: parse_query(&req),
        method: req.method().clone(),
        headers: req.headers().to_vec(),
        body: req.body().to_vec(),
        url: req.url().to_string(),
    };
    routes::posts::_postId::edit::get(ctx)
});
```

### Params Struct Placement and Sharing

- Each route gets its own `Params` type
- Routes without dynamic segments use an empty struct or the unit type `()`
- Routes that share a dynamic ancestor (e.g., `edit.rs` and `index.rs` under `_postId/`) share the same `Params` struct since it's defined at the directory level

### IDE Visibility Consideration

For full IDE support, the `Params` struct must be visible to rust-analyzer. If generated into `OUT_DIR`, the IDE may not see it.

**Practical solution:** Generate the `Params` structs into the source tree alongside the route files (e.g., as part of the `mod.rs` generation in each route directory). This is one case where generating into `src/` is justified by the DX benefit. The route tree *wiring* goes into `OUT_DIR` (it's mechanical), but the `Params` *types* stay in `src/` (developers import and use them directly).

### Naming Convention

The build script converts route segment names to Rust identifier convention:

| Route Segment | Params Field |
|---------------|-------------|
| `:postId` | `post_id` |
| `:userId` | `user_id` |
| `:id` | `id` |

CamelCase segments are converted to snake_case for the struct fields (standard Rust convention).

### Note: Handler Type — `fn` Pointer vs `Box<dyn Fn>`

The current `HandlerFn` is a function pointer (`fn(HttpRequest, RouteParams) -> HttpResponse<'static>`), not a trait object (`Box<dyn Fn(...)>`). This means handlers cannot be closures that capture state — all state access must go through thread-locals or statics. In the ICP canister context this is not a practical limitation, since canisters are single-threaded and thread-locals are the standard state management pattern. The `RouteContext<P>` change replaces the handler signature but does not need to change this constraint. If closure support is ever needed, it can be added independently by switching to `Box<dyn Fn(RouteContext<P>) -> HttpResponse<'static>>`, but this adds allocation overhead with no clear benefit in the current architecture.

## Files to Modify

- `src/build.rs` — Generate `Params` structs per route directory; generate wiring that constructs `RouteContext`
- New: `src/context.rs` — `RouteContext<P>` struct, `QueryParams` type
- `src/router.rs` — Update handler type to accept `RouteContext<P>` instead of `(HttpRequest, RouteParams)`
- `src/lib.rs` — Export `RouteContext`

## Acceptance Criteria

- [ ] Build script generates a `Params` struct for each route with dynamic segments
- [ ] `Params` fields are typed `String` with snake_case names derived from the route segment
- [ ] Routes without dynamic segments use `()` as the params type
- [ ] `RouteContext<P>` bundles params, query, method, headers, body, and url
- [ ] Handlers receive `RouteContext<Params>` instead of `(HttpRequest, RouteParams)`
- [ ] IDE completion works for `ctx.params.post_id` (rust-analyzer, VS Code, Neovim)
- [ ] Compile-time error if handler accesses a param that doesn't exist on the route
- [ ] Sibling routes under the same dynamic directory share the same `Params` struct
- [ ] Generated wiring correctly constructs `RouteContext` from raw request data
