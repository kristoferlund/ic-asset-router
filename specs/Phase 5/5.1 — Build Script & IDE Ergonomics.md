# 5.1 — Build Script & IDE Ergonomics

**Phase:** 5 — Developer Experience & Tooling
**Priority:** High
**Status:** Not started

## Problem

The build script faces a fundamental tension between source tree cleanliness and IDE support.

**The problem with illegal filenames:** The file-based routing convention uses names like `:pageId.rs` and `*.rs` which are valid on most filesystems but are not valid Rust identifiers. The current `build.rs` bridges this by generating `mod.rs` files with `#[path = "..."]` attributes (e.g., `#[path = ":pageId.rs"] pub mod pageId;`). This satisfies the compiler, but rust-analyzer's support for `#[path]` attributes is inconsistent — code completion, go-to-definition, and inline error reporting may not work for these modules.

**Generated files in source tree:** The build script writes `mod.rs` files into `src/routes/`, which can conflict with version control and IDE indexing. These files must either be committed (cluttering the repo) or `.gitignore`'d (creating a dependency on running the build before the IDE works).

## Objective

Adopt a file naming convention that uses only valid Rust identifiers, eliminating the need for `#[path]` attributes and giving full IDE support out of the box.

## Specification

### Three Strategies Compared

| Strategy | Source tree clean? | IDE support | Notes |
|----------|-------------------|-------------|-------|
| Generate into `OUT_DIR` | Yes | Poor — rust-analyzer struggles with `include!` into `OUT_DIR`; handler files are disconnected from the module tree | Cleanest for VCS, worst for DX |
| Generate `mod.rs` into `src/` (current) | No — generated files must be committed or `.gitignore`'d | Partial — `#[path]` attributes work for compilation but rust-analyzer may not follow them | Workable but messy |
| Use legal filenames only | Yes (no generation needed) | Full — standard Rust modules, everything just works | Requires giving up `:param` and `*` in filenames |

### Recommended Approach: Legal Filenames with a Naming Convention

Drop the unconventional characters entirely and adopt a convention that uses only valid Rust identifiers:

| Current | Proposed | Route |
|---------|----------|-------|
| `:pageId.rs` | `_pageId.rs` | `/deep/:pageId` |
| `:pageId/` (dir) | `_pageId/` (dir) | `/deep/:pageId/...` |
| `*.rs` | `all.rs` | `/*` |
| `not-found.rs` | `not_found.rs` | (reserved: 404 handler) |
| `middleware.rs` | `middleware.rs` | (reserved: middleware) |

The underscore prefix `_` signals "this is a dynamic segment" while remaining a valid Rust identifier. The build script maps `_pageId` back to `:pageId` in the route tree. This works for both files (`_pageId.rs`) and directories (`_pageId/`), so dynamic segments can have nested child routes.

Reserved filenames (`all.rs`, `not_found.rs`, `middleware.rs`) use plain names without a prefix — the build script recognizes them by exact name.

### Example: Nested Dynamic Routes with Static Children

```
src/routes/
  index.rs                          -> /
  all.rs                            -> /* (catch-all)
  not_found.rs                      -> (404 handler)
  middleware.rs                     -> (global middleware)
  about.rs                          -> /about
  posts/
    index.rs                        -> /posts
    _postId/
      index.rs                      -> /posts/:postId
      edit.rs                       -> /posts/:postId/edit
      ogimage.rs                    -> /posts/:postId/ogimage
```

The `_postId/` directory is a valid Rust module name and a valid filesystem directory. It maps to the `:postId` dynamic segment, and its children define sub-routes under that segment.

### File vs Directory Shorthand

A file and its equivalent directory-with-index are interchangeable shorthands:

- `_postId.rs` is equivalent to `_postId/index.rs` — both map to `/posts/:postId`
- The file form is a shorthand for when the dynamic segment has no child routes
- The directory form is required when there are child routes under the segment

The build script must enforce that both forms do not coexist. If `_postId.rs` and `_postId/index.rs` are both present, it should emit a compile-time error indicating the ambiguity.

### File Extensions in Route URLs

A route like `/posts/:postId/ogimage.png` (where the handler dynamically generates a PNG) cannot be represented as `ogimage.png.rs` because dots are not valid in Rust identifiers.

The approach is two-layered:

- **Default:** The filename maps directly to the URL segment without any extension. The file `ogimage.rs` maps to the route `/posts/:postId/ogimage`. The handler sets the appropriate `Content-Type` header. This is sufficient for most cases — API endpoints, HTML pages, and any route where the URL doesn't need a file extension.

- **Escape hatch:** When the URL genuinely needs a file extension (e.g., social media crawlers that require `.png` in the URL to recognize an image), a `#[route]` attribute overrides the filename-derived path segment:

  ```rust
  // src/routes/posts/_postId/ogimage.rs
  //
  // Without the attribute, this would map to /posts/:postId/ogimage
  // With the attribute, it maps to /posts/:postId/ogimage.png

  #[route(path = "ogimage.png")]
  pub fn get(req: HttpRequest, params: RouteParams) -> HttpResponse<'static> {
      // generate PNG dynamically
  }
  ```

  The build script scans for `#[route(path = "...")]` attributes and uses the specified value instead of the filename when constructing the route tree. This requires the build script to do lightweight parsing of the handler source (a regex scan for the attribute is sufficient — full `syn` parsing is not necessary).

  The `#[route]` attribute also generalizes to other per-route configuration in the future:

  ```rust
  #[route(path = "ogimage.png", cache_control = "public, max-age=3600")]
  pub fn get(req: HttpRequest, params: RouteParams) -> HttpResponse<'static> { ... }
  ```

### Generated Route Tree Wiring

This eliminates the need for `#[path = "..."]` attributes entirely. Every route file is a normal Rust module. rust-analyzer, Neovim LSP, VS Code — all work out of the box with full code completion, go-to-definition, and inline diagnostics.

The trade-off is slightly less visual clarity in the filesystem (`_pageId` vs `:pageId`), but the gain in tooling reliability is worth it.

### Additional Improvements

- **Configurable route directory:** Not hardcoded to `src/routes/`. Allow setting via build script configuration.
- **Route tree wiring into `OUT_DIR`:** Generate the route tree wiring (currently `__route_tree.rs`) into `OUT_DIR` and pull it in via `include!`. This is the one generated file that doesn't need IDE navigation — it's purely mechanical wiring. The actual handler files remain normal `src/` modules.
- **Route manifest:** Generate a route manifest (JSON or text) into `OUT_DIR` for debugging and inspection. Lists all registered routes, their handler functions, methods, and parameters.

## Files to Modify

- `src/build.rs` — Rewrite to use new naming convention; scan for `#[route]` attributes; generate wiring into `OUT_DIR`; make route directory configurable
- All existing `src/routes/` files in consumer projects — Rename from `:param.rs` to `_param.rs`, `*.rs` to `all.rs`
- Migration guide documentation

## Acceptance Criteria

- [ ] `_param` prefix in filenames maps to `:param` dynamic segments in routes
- [ ] `all.rs` maps to `/*` catch-all routes
- [ ] `not_found.rs` and `middleware.rs` are recognized as reserved filenames
- [ ] File/directory ambiguity (`_postId.rs` + `_postId/index.rs`) produces a compile-time error
- [ ] `#[route(path = "...")]` attribute overrides the filename-derived URL segment
- [ ] Build script scans for `#[route]` attributes via regex (no `syn` dependency)
- [ ] Route tree wiring is generated into `OUT_DIR`, not `src/`
- [ ] Route directory is configurable (not hardcoded to `src/routes/`)
- [ ] Route manifest (JSON) is generated into `OUT_DIR`
- [ ] rust-analyzer provides full code completion and go-to-definition for all route modules
- [ ] No `#[path = "..."]` attributes are used anywhere
