# 5.5 — Unit & Property Tests

**Phase:** 5 — Developer Experience & Tooling
**Priority:** High
**Status:** Not started

## Problem

The library has some unit tests added during Phase 1 (router matching, config presets, error handling), but coverage is incomplete. The trie-based routing, build script code generation, middleware chain, cache invalidation logic, and edge cases are not thoroughly tested. All ICP-specific behavior (certification, the query→upgrade→update flow, HTTP serving) is untested at the unit level because it requires IC runtime APIs.

This spec covers unit tests and property-based tests — the things that can run with `cargo test` without any ICP infrastructure. End-to-end tests using PocketIC are covered separately in spec 5.7.

## Pre-Implementation Step: Audit Existing Tests

Before writing new tests, audit what already exists:

- `src/router.rs` — Trie matching, param extraction, wildcard capture, precedence, method dispatch, middleware chain, not_found handling
- `src/config.rs` — SecurityHeaders presets, CacheControl defaults, header merging
- `src/lib.rs` — Malformed URL handling (400), content-type extraction, missing content-type safety

Identify gaps and avoid duplicating existing coverage.

## Objective

Expand the unit test suite to cover all non-ICP logic, and add property-based tests for the trie router.

## Specification

### Unit Test Gaps to Fill

Areas not yet covered (or insufficiently covered):

**Router edge cases:**
- Trailing slashes (`/about/` vs `/about`)
- Double slashes (`//about`)
- Empty segments
- URL-encoded characters (`/posts/hello%20world`)
- Very long paths
- Routes with many parameters

**Middleware chain:**
- Middleware execution order (directory hierarchy)
- Middleware modifying requests before handler
- Middleware short-circuiting (returning early without calling handler)
- Multiple middleware in a chain

**Cache invalidation logic (Phase 4):**
- `invalidate_path` removes correct entry
- `invalidate_prefix` matches correctly, doesn't over-match
- `invalidate_all_dynamic` clears dynamic but not static
- TTL expiry calculation (`certified_at + ttl < now`)
- `HandlerResult::NotModified` preserves cache entry and resets TTL

**Build script code generation:**
- `_param` → `:param` mapping
- `all.rs` → `/*` mapping
- `index.rs` → directory path mapping
- `#[route(path = "...")]` attribute scanning
- Reserved filename recognition (`middleware.rs`, `not_found.rs` skipped as routes)
- Nested directory structures
- Edge cases: empty routes dir, deeply nested dirs

**Config:**
- Custom CacheControl values propagate correctly
- Per-route header overrides (last-write-wins)
- Case-insensitive header name matching in merges

### Property-Based Tests

Add `proptest` as a dev-dependency and verify trie invariants:

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn inserted_routes_are_always_found(path in "/[a-z/]{1,50}") {
        let mut root = RouteNode::new(NodeType::Static("".into()));
        root.insert(&path, Method::GET, dummy_handler);
        match root.resolve(&path, &Method::GET) {
            RouteResult::Found(_, _) => {},
            other => panic!("expected Found, got {:?}", other),
        }
    }

    #[test]
    fn non_inserted_routes_are_not_found(
        inserted in "/[a-z]{1,10}",
        queried in "/[a-z]{1,10}"
    ) {
        prop_assume!(inserted != queried);
        let mut root = RouteNode::new(NodeType::Static("".into()));
        root.insert(&inserted, Method::GET, dummy_handler);
        match root.resolve(&queried, &Method::GET) {
            RouteResult::NotFound => {},
            _ => panic!("expected NotFound for non-inserted route"),
        }
    }

    #[test]
    fn param_routes_capture_any_segment(
        prefix in "/[a-z]{1,5}",
        value in "[a-z0-9]{1,20}"
    ) {
        let route = format!("{}/:id", prefix);
        let path = format!("{}/{}", prefix, value);
        let mut root = RouteNode::new(NodeType::Static("".into()));
        root.insert(&route, Method::GET, dummy_handler);
        match root.resolve(&path, &Method::GET) {
            RouteResult::Found(_, params) => {
                assert_eq!(params.get("id"), Some(&value));
            },
            _ => panic!("expected Found"),
        }
    }
}
```

### Build Script Tests

The build script (`src/build.rs`) is pure Rust with no ICP dependencies — its code generation logic should be testable with regular unit tests. Test the directory-scanning and route-path-generation functions in isolation by providing mock directory structures (in-memory or via `tempdir`).

## Files to Modify

- `src/router.rs` — Expand `#[cfg(test)]` module with edge case tests
- `src/config.rs` — Expand tests for config edge cases
- `src/build.rs` — Add `#[cfg(test)]` module for code generation tests
- `src/assets.rs` — Add tests for invalidation logic (if Phase 4 is complete)
- `Cargo.toml` — Add `proptest` as dev-dependency

## Acceptance Criteria

- [ ] Existing tests audited — gaps documented before writing new tests
- [ ] Router edge cases covered: trailing slashes, double slashes, URL encoding, long paths
- [ ] Middleware chain tests: execution order, short-circuit, modification
- [ ] Cache invalidation tests (if Phase 4 complete): path, prefix, all_dynamic, TTL expiry
- [ ] Build script code generation tests: param mapping, wildcard mapping, reserved filenames
- [ ] Property-based tests verify trie invariants with randomized inputs
- [ ] All tests run without ICP runtime (`cargo test` succeeds)
- [ ] `proptest` added as dev-dependency only (not a runtime dependency)
