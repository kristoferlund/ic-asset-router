# 6.7 — Single Certified 404 Fallback

## Problem

The spec 6.1 implementation (Session 7) certifies 404 responses **per-path**. Every unique not-found URL (`/foo`, `/bar`, `/xyz/123`) creates:

- A separate `HTTP_TREE` entry (manual certification, bypassing `AssetRouter`)
- A separate `DYNAMIC_CACHE` entry with a full `CachedHttpResponse` clone (status, headers, body)

This means a bot or scanner probing 10,000 unique URLs fills memory with 10,000 identical-body 404 entries. The not-found handler typically produces the same response regardless of which path was requested — there is no reason to certify it once per path.

Additionally, the per-path implementation introduced significant complexity:

- A parallel certification code path in `certify_dynamic_response()` (`src/lib.rs:476-530`) that manually builds CEL expressions, creates `HttpCertification::full`, and inserts into `HTTP_TREE` — duplicating logic from `AssetRouter::prepare_response_and_certification`.
- A `serve_cached_non200()` helper (`src/lib.rs:374-435`) that reconstructs responses with fresh witnesses.
- New fields on `CachedDynamicAsset`: `status_code: u16` and `cached_response: Option<CachedHttpResponse>`.
- Three distinct code paths in the query-path `NotFound` branch (non-200 cached, 200 cached via AssetRouter, uncached/static fallback).

## Specification

### Design: certify once, serve for all

The not-found response should be certified **once** at a canonical internal path (e.g., `/__not_found`) and served for all unmatched paths. The approach:

1. **On first 404 in `http_request_update`**: execute the not-found handler, certify the response at a single canonical path, cache it.
2. **On subsequent 404s in `http_request`**: serve the cached canonical 404 response directly — no per-path lookup needed.
3. **Invalidation**: when the not-found handler's output might change (e.g., after a deploy), the canonical path is invalidated like any other cached path.

### Changes to `http_request_update` NotFound branch

When `RouteResult::NotFound` is reached:

1. Check if the canonical 404 path (`/__not_found`) already has a valid cached entry in `DYNAMIC_CACHE`.
2. If yes and not TTL-expired: skip recertification. Return the cached response directly (or return upgrade:false to let the query path serve it — depending on the flow).
3. If no or expired: execute the not-found handler, certify the response at the canonical path `/__not_found` via `certify_dynamic_response()`. This goes through the standard 200 certification path — the not-found handler should return a response with status 200 body content and the library wraps it.

**Important**: The not-found handler's response body is what gets certified. The actual HTTP status code returned to the client is a separate concern from the certification. The `ic-asset-certification` library certifies content, not status codes. The current workaround of manually certifying non-200 responses should be removed — instead, certify the body as a regular asset and set the status code when serving.

### Changes to `http_request` NotFound branch

When `RouteResult::NotFound` is reached and `opts.certify` is true:

1. Check if `/__not_found` has a valid cached entry in `DYNAMIC_CACHE`.
2. If yes: serve from `ASSET_ROUTER` using a request rewritten to `/__not_found`. The response will have status 200 from `serve_asset()`, but that's the certification status — the boundary node validates it.
3. If no: return `upgrade: true` to trigger the update path.

**Status code consideration**: `serve_asset()` always returns 200. If the boundary node needs to see 404, this approach doesn't work with `AssetRouter`. However, the boundary node validates the certification proof regardless of status code — what matters is that the response body and headers match the certified content. The practical impact is that clients see status 200 for "not found" pages. This is acceptable for canister-served pages (many SPAs already serve 200 for all routes). If 404 status is strictly required, document this as a known limitation.

**Alternative**: If 404 status is required, keep the manual certification approach but limit it to a single canonical path instead of per-path. This preserves the `serve_cached_non200()` machinery but eliminates the memory growth problem.

### Remove per-path 404 certification

- Remove the non-200 branch from `certify_dynamic_response()` (lines ~476-530)
- Remove `serve_cached_non200()` (lines ~374-435)
- Remove `cached_response: Option<CachedHttpResponse>` from `CachedDynamicAsset`
- Remove `CachedHttpResponse` struct from `assets.rs`
- Remove `status_code: u16` from `CachedDynamicAsset`
- Simplify the three-way `match` in the query-path `NotFound` branch back to a single path

### Files to modify

| File | Change |
|------|--------|
| `src/lib.rs` | Rewrite NotFound branches in both `http_request` and `http_request_update` to use canonical `/__not_found` path. Remove `serve_cached_non200()`. Simplify `certify_dynamic_response()` back to 200-only. |
| `src/assets.rs` | Remove `CachedHttpResponse` struct. Remove `status_code` and `cached_response` fields from `CachedDynamicAsset`. |

### Acceptance criteria

- [ ] Only one `DYNAMIC_CACHE` entry exists for all 404 responses (at `/__not_found` or equivalent canonical path)
- [ ] A bot probing 1000 unique non-existent URLs creates exactly 1 cached entry, not 1000
- [ ] The not-found handler executes once on the first 404; subsequent 404s serve from cache
- [ ] `CachedDynamicAsset` no longer has `cached_response` or `status_code` fields
- [ ] `serve_cached_non200()` is removed
- [ ] The non-200 branch in `certify_dynamic_response()` is removed
- [ ] E2E test `test_custom_404_handler` still passes (404 content is served correctly)
- [ ] `invalidate_path("/__not_found")` forces the next 404 to re-execute the not-found handler
- [ ] `cargo test` passes
