# 4.1 — TTL-Based Cache Invalidation

**Phase:** 4 — Dynamic Asset Lifecycle
**Priority:** Medium
**Status:** Not started

## Problem

Once a dynamic asset is certified at a path, subsequent query calls serve the cached version indefinitely. There is no way to set expiry times on cached dynamic content. A blog post's meta tags are cached forever after first generation — if the post title changes, the old meta tags are served until someone manually calls `delete_assets`.

Different types of dynamic content have different freshness requirements:
- Meta tags for a published blog post → might be fine cached for hours
- A real-time dashboard page → needs frequent regeneration
- A user profile page → should update when the profile changes

There is no mechanism to express these different cache durations.

## Objective

Allow handlers to specify a time-to-live for their generated responses, so the library automatically triggers re-generation when the TTL expires.

## Specification

### DynamicResponse with TTL

Each dynamic asset can have a time-to-live:

```rust
pub struct DynamicResponse {
    pub body: Vec<u8>,
    pub content_type: String,
    pub ttl: Option<Duration>,  // None = cache forever (current behavior)
    pub headers: Vec<HeaderField>,
}
```

### Cache Validity Check

When a query call finds a cached dynamic asset:

1. Check if the asset has a TTL set
2. If TTL is set, compare: `creation_time + ttl < ic_cdk::api::time()`
3. If expired → return `upgrade: true` to trigger an update call (regenerate and re-certify)
4. If not expired → serve from cache as normal
5. If no TTL → serve from cache indefinitely (backwards-compatible)

### Timestamp Tracking

The library needs to track when each dynamic asset was certified:

```rust
struct CachedDynamicAsset {
    response: HttpResponse,
    certified_at: u64,      // ic_cdk::api::time() nanoseconds
    ttl: Option<Duration>,
}
```

This metadata is stored alongside the existing cached response, likely in the same thread-local storage that manages the asset router state.

### ICP Time Considerations

ICP canisters use `ic_cdk::api::time()` which returns nanoseconds since the UNIX epoch. This is set by consensus and is reliable for the purposes of cache expiry (resolution is in the seconds range). However:

- **Query calls** see a slightly stale time (the time of the last certified state). This is fine — a few seconds of staleness in TTL checking is acceptable.
- **Update calls** see the current consensus time.
- The time is not wall-clock precise but is monotonically increasing and consistent across replicas.

### Global Cache Configuration

```rust
pub struct CacheConfig {
    pub default_ttl: Option<Duration>,              // Applied to all dynamic assets without explicit TTL
    pub per_route_ttl: HashMap<String, Duration>,   // Per-route overrides
}
```

### Pros and Cons

**Pros:**
- Simple and predictable behavior
- Automatic — no application code needed beyond setting the TTL
- Backwards-compatible (default is no TTL = cache forever)

**Cons:**
- Content may be stale until TTL expires (not immediately fresh)
- First request after expiry pays the update call latency penalty
- ICP time resolution means sub-second TTLs are not meaningful

### Relationship to Explicit Invalidation (4.2)

TTL and explicit invalidation are complementary:
- TTL acts as a safety net — even if the application forgets to invalidate, content eventually refreshes
- Explicit invalidation provides immediate freshness when the application knows data changed
- The hybrid approach (both TTL and explicit invalidation) is the recommended end state

## Files to Modify

- `src/lib.rs` — Check TTL validity in query path before serving cached response; trigger upgrade if expired
- `src/assets.rs` — Store certification timestamps alongside cached assets; add `CachedDynamicAsset` struct
- `src/config.rs` — Add `CacheConfig` with default and per-route TTL settings

## Acceptance Criteria

- [ ] Handlers can return a `DynamicResponse` with `ttl: Some(Duration::from_secs(3600))`
- [ ] Cached assets with expired TTL trigger an update call on next request
- [ ] Cached assets without TTL continue to be served indefinitely (backwards-compatible)
- [ ] `ic_cdk::api::time()` is used for timestamp tracking
- [ ] Global default TTL can be configured via `CacheConfig`
- [ ] Per-route TTL overrides work
- [ ] Certification timestamps are tracked for all dynamic assets
