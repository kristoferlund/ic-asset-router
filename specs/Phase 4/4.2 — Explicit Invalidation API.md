# 4.2 — Explicit Invalidation API

**Phase:** 4 — Dynamic Asset Lifecycle
**Priority:** High
**Status:** Not started

## Problem

The only mechanism for clearing cached dynamic assets is `delete_assets`, which is coarse-grained and must be called manually. There is no way to:

- Invalidate a single cached path (e.g., when a specific blog post is updated)
- Invalidate all paths under a prefix (e.g., all `/posts/*` when the post listing changes)
- Invalidate all dynamic assets while leaving static assets untouched

This means applications that update their data must either call `delete_assets` (which is all-or-nothing) or build their own invalidation tracking on top of the library.

## Objective

Provide a granular invalidation API that lets applications precisely control which cached dynamic assets are cleared, triggering re-generation on the next request.

## Specification

### Invalidation Functions

```rust
/// Invalidate a single cached dynamic asset by exact path.
/// The next request to this path will trigger an update call to regenerate.
pub fn invalidate_path(path: &str);

/// Invalidate all cached dynamic assets whose path starts with the given prefix.
/// Example: invalidate_prefix("/posts/") clears /posts/1, /posts/2, etc.
pub fn invalidate_prefix(prefix: &str);

/// Invalidate all dynamically generated assets.
/// Static assets (embedded at compile time) are unaffected.
pub fn invalidate_all_dynamic();
```

### Behavior

When a path is invalidated:
1. The cached response is removed (or marked as invalid) in the asset store
2. The certification proof for that path is removed from the hash tree
3. The root hash is updated
4. The next query call for that path will find no valid cached response and return `upgrade: true`
5. The subsequent update call regenerates, re-certifies, and caches the new response

### Invalidation During Update Calls

Invalidation is most commonly triggered during update calls — when the application modifies its data:

```rust
// Example: when a blog post is updated
#[update]
fn update_post(id: u64, new_title: String, new_content: String) {
    // Update the post in canister storage
    POSTS.with(|posts| {
        posts.borrow_mut().insert(id, Post { title: new_title, content: new_content });
    });

    // Invalidate the cached dynamic response for this post
    asset_router::invalidate_path(&format!("/posts/{}", id));

    // Also invalidate the posts listing page if it exists
    asset_router::invalidate_path("/posts");
}
```

### Canister Upgrade Hook

Provide clear guidance for invalidating during canister upgrades:

```rust
#[post_upgrade]
fn post_upgrade() {
    // Clear all stale dynamic content from the previous version
    asset_router::invalidate_all_dynamic();

    // Re-certify static assets (they may have changed in the new WASM)
    asset_router::certify_all_assets();
}
```

This ensures stale dynamic content doesn't survive upgrades. The recommendation is to **always** call `invalidate_all_dynamic()` in `post_upgrade`.

### Static Asset Safety

All invalidation functions operate **only** on dynamically generated assets. Static assets (embedded via `include_dir` and certified during `certify_all_assets`) are never affected. The library must maintain a clear distinction between static and dynamic entries in its internal storage.

### Recommendation

Start with explicit invalidation as the primary cache management strategy. This is the most predictable approach and matches how most ICP canisters work:
- Data changes happen in update calls
- The same update call can trigger invalidation
- No timing assumptions, no clock dependencies
- Immediate freshness when the application knows data changed

TTL-based invalidation (4.1) can be added later as a complementary safety net.

## Files to Modify

- `src/assets.rs` — Add `invalidate_path()`, `invalidate_prefix()`, `invalidate_all_dynamic()` functions; maintain static vs. dynamic asset distinction
- `src/lib.rs` — Ensure invalidated paths correctly trigger upgrade to update call
- `src/lib.rs` — Export invalidation functions

## Acceptance Criteria

- [ ] `invalidate_path("/posts/42")` causes the next request to `/posts/42` to regenerate the asset
- [ ] `invalidate_prefix("/posts/")` clears all cached assets whose path starts with `/posts/`
- [ ] `invalidate_all_dynamic()` clears all cached dynamic assets
- [ ] Invalidated paths trigger upgrade to update call on next request
- [ ] Static assets are unaffected by all invalidation functions
- [ ] Root hash is updated after invalidation
- [ ] Canister upgrade documentation recommends calling `invalidate_all_dynamic()` in `post_upgrade`
- [ ] Invalidation can be called from within update call handlers
