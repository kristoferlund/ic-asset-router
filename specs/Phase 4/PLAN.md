# Phase 4 — Implementation Plan

**Scope:** Specs 4.1, 4.2, 4.3
**Library:** `~/gh/router_library/`
**Status:** Not started

## Dependency Order

```
4.2 (explicit invalidation) — independent, no internal deps
4.1 (TTL-based cache)       — depends on 4.2 (dynamic asset tracking infrastructure)
4.3 (conditional regen)     — depends on 4.1 (TTL reset) and 4.2 (cached asset metadata)
```

**Rationale:** 4.2 is the highest priority item and the most self-contained. It introduces the static-vs-dynamic asset distinction and the core invalidation functions. 4.1 builds on this by adding timestamp tracking and TTL checking to the dynamic asset metadata. 4.3 is the lowest priority and depends on both — it adds `HandlerResult::NotModified` which interacts with both TTL reset and cached asset metadata.

Note: The spec for 4.2 explicitly recommends starting with explicit invalidation as the primary strategy, with TTL added later as a complementary safety net. This confirms the execution order.

---

## Tasks

### 4.2 — Explicit Invalidation API

#### Dynamic Asset Registry

The library currently delegates all asset storage to `ic-asset-certification`'s `AssetRouter`. To distinguish dynamic from static assets and to support selective invalidation, the library needs its own tracking of which paths were dynamically generated.

- [x] **4.2.1** Create a `thread_local!` registry for dynamic asset paths in `src/lib.rs` (e.g., `DYNAMIC_PATHS: RefCell<HashSet<String>>`) — tracks which paths were generated by handlers vs embedded at compile time
- [x] **4.2.2** In `http_request_update`, after certifying a dynamic response, insert the path into `DYNAMIC_PATHS`
- [x] **4.2.3** Verify: `cargo check` succeeds

#### Invalidation Functions

- [x] **4.2.4** Implement `invalidate_path(path: &str)` in `src/assets.rs` — removes the path from `ASSET_ROUTER` (via `delete_assets_by_path`) and from `DYNAMIC_PATHS`, then updates the root hash
- [x] **4.2.5** Implement `invalidate_prefix(prefix: &str)` in `src/assets.rs` — iterates `DYNAMIC_PATHS`, collects all paths starting with the prefix, removes them from both `ASSET_ROUTER` and `DYNAMIC_PATHS`, updates the root hash
- [x] **4.2.6** Implement `invalidate_all_dynamic()` in `src/assets.rs` — collects all paths from `DYNAMIC_PATHS`, removes them from `ASSET_ROUTER`, clears `DYNAMIC_PATHS`, updates the root hash
- [x] **4.2.7** Export `invalidate_path`, `invalidate_prefix`, `invalidate_all_dynamic` from `src/lib.rs`
- [x] **4.2.8** Verify: `cargo check` succeeds

#### Invalidation Behavior Verification

- [x] **4.2.9** Add test: after inserting a path into `DYNAMIC_PATHS` and calling `invalidate_path`, the path is no longer in `DYNAMIC_PATHS`
- [x] **4.2.10** Add test: `invalidate_prefix("/posts/")` removes `/posts/1`, `/posts/2` but not `/about`
- [x] **4.2.11** Add test: `invalidate_all_dynamic()` clears all entries from `DYNAMIC_PATHS`
- [x] **4.2.12** Add test: static assets (not in `DYNAMIC_PATHS`) are unaffected by all invalidation functions
- [x] **4.2.13** Verify: `cargo test` passes

### 4.1 — TTL-Based Cache Invalidation

*Depends on: 4.2 (DYNAMIC_PATHS registry must exist)*

#### Cached Asset Metadata

- [x] **4.1.1** Replace `DYNAMIC_PATHS: RefCell<HashSet<String>>` with a richer metadata store: `DYNAMIC_CACHE: RefCell<HashMap<String, CachedDynamicAsset>>` where `CachedDynamicAsset` contains `certified_at: u64` and `ttl: Option<Duration>`
- [x] **4.1.2** Update 4.2's invalidation functions to work with `DYNAMIC_CACHE` (HashMap) instead of `DYNAMIC_PATHS` (HashSet) — same logic, different data structure
- [x] **4.1.3** Verify: `cargo check` succeeds and existing 4.2 tests still pass after the data structure change

#### TTL Recording

- [x] **4.1.4** In `http_request_update`, after certifying a dynamic response, insert a `CachedDynamicAsset` entry with `certified_at: ic_cdk::api::time()` and `ttl: None` (default — no expiry, backwards-compatible)
- [x] **4.1.5** Verify: `cargo check` succeeds

#### CacheConfig

- [x] **4.1.6** Add `CacheConfig` struct to `src/config.rs` with `default_ttl: Option<Duration>` and `per_route_ttl: HashMap<String, Duration>`
- [x] **4.1.7** Add `cache_config: CacheConfig` field to `AssetConfig`
- [x] **4.1.8** Implement `Default for CacheConfig` — `default_ttl: None`, empty `per_route_ttl`
- [x] **4.1.9** Verify: `cargo check` succeeds

#### TTL Checking in Query Path

- [x] **4.1.10** In `http_request` (the query call path, `certify: true` branch), before serving from `ASSET_ROUTER`, check `DYNAMIC_CACHE` for the requested path: if the entry has a TTL and `certified_at + ttl < ic_cdk::api::time()`, return `upgrade: true` instead of serving the cached response
- [x] **4.1.11** If the entry has no TTL, check `CacheConfig::default_ttl` and `CacheConfig::per_route_ttl` as fallbacks
- [x] **4.1.12** If no TTL is configured anywhere (entry, per-route, or default), serve from cache indefinitely (backwards-compatible)
- [x] **4.1.13** Verify: `cargo check` succeeds

#### TTL Application in Update Path

- [x] **4.1.14** In `http_request_update`, when recording the `CachedDynamicAsset`, resolve the effective TTL: check handler response for a TTL hint (if `DynamicResponse` is implemented), then `CacheConfig::per_route_ttl`, then `CacheConfig::default_ttl`, then `None`
- [x] **4.1.15** Verify: `cargo check` succeeds

#### Tests

- [x] **4.1.16** Add test: `CacheConfig::default()` has `default_ttl: None` and empty `per_route_ttl`
- [x] **4.1.17** Add test: a `CachedDynamicAsset` with `ttl: None` never expires (is_expired returns false)
- [x] **4.1.18** Add test: a `CachedDynamicAsset` with `ttl: Some(3600s)` and `certified_at` in the past is correctly identified as expired
- [x] **4.1.19** Add test: a `CachedDynamicAsset` with `ttl: Some(3600s)` and `certified_at` now is not expired
- [x] **4.1.20** Add test: per-route TTL overrides default TTL
- [x] **4.1.21** Verify: `cargo test` passes

### 4.3 — Conditional Regeneration

*Depends on: 4.1 (CachedDynamicAsset with timestamps), 4.2 (DYNAMIC_CACHE)*

#### HandlerResult Type

- [x] **4.3.1** Define `HandlerResult` enum in `src/router.rs` (or a new `src/response.rs`): `Response(HttpResponse<'static>)` and `NotModified`
- [x] **4.3.2** Implement `From<HttpResponse<'static>> for HandlerResult` so existing handlers returning `HttpResponse` work without changes
- [x] **4.3.3** Verify: `cargo check` succeeds

#### last_certified_at Query

- [x] **4.3.4** Add `pub fn last_certified_at(path: &str) -> Option<u64>` that reads from `DYNAMIC_CACHE` and returns the `certified_at` timestamp if the path exists
- [x] **4.3.5** Export `last_certified_at` from `src/lib.rs`
- [x] **4.3.6** Verify: `cargo check` succeeds

#### NotModified Handling in Update Path

- [x] **4.3.7** Modify `http_request_update`: if the handler returns `HandlerResult::NotModified`, skip recertification entirely — do not call `asset_router.certify_assets()`, do not update the root hash
- [x] **4.3.8** If `NotModified` is returned and TTL-based caching is active, reset the `certified_at` timestamp in `DYNAMIC_CACHE` to the current time (content confirmed fresh, TTL resets)
- [x] **4.3.9** If `NotModified` is returned, serve the existing cached response (read from `ASSET_ROUTER`)
- [x] **4.3.10** Verify: `cargo check` succeeds

#### Tests

- [x] **4.3.11** Add test: `From<HttpResponse> for HandlerResult` conversion works correctly
- [x] **4.3.12** Add test: `last_certified_at` returns `None` for uncached paths
- [x] **4.3.13** Add test: `last_certified_at` returns `Some(timestamp)` for cached paths
- [x] **4.3.14** Add test: `NotModified` preserves the existing entry in `DYNAMIC_CACHE`
- [x] **4.3.15** Add test: `NotModified` resets the `certified_at` timestamp when TTL is active
- [x] **4.3.16** Verify: `cargo test` passes

---

## Verification Protocol

After each spec is complete, run:

```
cargo check
cargo test
```

Both must pass before marking the spec as done.

After all Phase 4 specs are complete, run a final check:

```
cargo check
cargo test
cargo doc --no-deps
```

---

## Session Boundaries

Each OpenCode session works on **one spec** (e.g., all tasks under 4.2). When all tasks for that spec are checked off and verified, the session ends. The next session picks up the next spec.

**Why one spec per session:**
- Context stays focused on one concern (invalidation API, TTL mechanism, conditional regen)
- No context pollution from unrelated file reads and failed attempts
- The plan file carries state between sessions — nothing is lost
- If the agent degrades mid-spec, you lose at most one spec's worth of work

**When to stop early (before completing the spec):**
- After a failed verification (`cargo check` or `cargo test` fails) and one fix attempt also fails — stop, start fresh. The next session sees the partial work in the code and the still-unchecked task in the plan.
- If the agent starts producing low-quality output (repeating itself, making contradictory changes, ignoring test failures) — stop. Context is degraded.

**After each session:**
- The agent must have committed its work before stopping
- Verify the plan file was updated (tasks checked off)

## Session Prompt Template

At the start of each OpenCode session, use this prompt:

```
You are implementing changes to a Rust library at ~/gh/router_library/.

PLAN FILE: ~/bee/BEE NOTES/Projects/Asset Router/Phase 4/PLAN.md
SPEC FILES: ~/bee/BEE NOTES/Projects/Asset Router/Phase 4/

Instructions:
1. Read the plan file (PLAN.md).
2. Find the next incomplete spec (the first spec group with unchecked tasks).
3. Read the corresponding spec file for that spec (e.g., "4.2 — Explicit Invalidation API.md").
4. Study the library source files relevant to that spec.
5. Implement each unchecked task in that spec group, in order.
6. After each task: run `cargo check`. If it fails, fix before continuing.
7. After completing all tasks in the spec group: run `cargo test`. Fix any failures.
8. Mark completed tasks in PLAN.md (change `[ ]` to `[x]`).
9. Append a session summary to SESSION.md (in the same directory as PLAN.md).
   The summary must include:
   - A heading with the session name (e.g., "## Session: Spec 4.2 — Explicit Invalidation API")
   - Date
   - What was accomplished (tasks completed, brief description)
   - Obstacles encountered (compilation errors, test failures, unclear specs, workarounds applied)
   - Out-of-scope observations: anything noticed during implementation that should be
     addressed elsewhere in the codebase but was not part of this session's tasks.
     These may become new specs or tasks in future phases.
   Create the file if it does not exist. Append to it if it does.
10. Commit all changes: `git add -A && git commit -m "spec X.X: <brief description>"`
11. STOP after completing one spec group. Do not continue to the next spec.

Rules:
- Do not skip tasks. Do not reorder tasks within a spec group.
- If `cargo check` or `cargo test` fails and your fix attempt also fails, STOP.
  Mark the failing task with `[!]` in PLAN.md and describe the failure briefly.
  Still commit whatever partial work exists before stopping.
- Ask before installing new dependencies.
- Do not modify files outside ~/gh/router_library/ except for PLAN.md and SESSION.md.
- ALWAYS commit before stopping. Every session must end with a git commit.
```

Adjust the prompt to request a specific spec if you want to override the sequential order.
