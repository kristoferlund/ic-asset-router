# 4.3 — Conditional Regeneration

**Phase:** 4 — Dynamic Asset Lifecycle
**Priority:** Low
**Status:** Not started

## Problem

When a dynamic asset's cache expires (via TTL) or is explicitly invalidated, the next request triggers a full regeneration via the update call path. The handler re-executes, produces a response, and the library re-certifies it — even if the content hasn't actually changed.

Recertification involves:
1. Re-executing the handler (which may involve fetching data from stable memory)
2. Computing the certification hash for the response
3. Updating the hash tree
4. Updating the root hash

If the underlying data hasn't changed, this is wasted computation. On ICP, update calls consume cycles and take longer than query calls, so unnecessary regeneration has a real cost.

## Objective

Allow handlers to signal "nothing has changed" so the library can keep the existing certified version, avoiding unnecessary recertification overhead.

## Specification

### HandlerResult Enum

Replace the simple response return with a result type that allows a "not modified" signal:

```rust
pub enum HandlerResult {
    /// New content — certify and cache this response
    Response(DynamicResponse),

    /// Content hasn't changed — keep the existing certified version
    /// and reset the TTL timer (if TTL-based caching is enabled)
    NotModified,
}
```

### Handler Implementation

The handler can check whether regeneration is actually needed:

```rust
pub fn get(ctx: RouteContext<Params>) -> HandlerResult {
    let post = load_post(&ctx.params.post_id);

    // Compare with the last known version
    if post.updated_at <= last_certified_time_for_path(&ctx.url) {
        return HandlerResult::NotModified;
    }

    HandlerResult::Response(DynamicResponse {
        body: render_post_html(&post).into_bytes(),
        content_type: "text/html".to_string(),
        ttl: Some(Duration::from_secs(3600)),
        headers: vec![],
    })
}
```

### NotModified Behavior

When a handler returns `NotModified`:
1. The existing cached response remains in the asset store
2. The existing certification proof remains valid
3. If TTL-based caching is active, the TTL timer is **reset** (the content was confirmed fresh)
4. The next query call continues to serve the cached version
5. No hash tree updates, no root hash changes

### Providing Context to the Handler

For the handler to decide whether regeneration is needed, it may need to know when the current cached version was certified. The library can provide this via the `RouteContext`:

```rust
pub struct RouteContext<P, S = ()> {
    pub params: P,
    pub search: S,
    pub method: Method,
    pub headers: Vec<HeaderField>,
    pub body: Vec<u8>,
    pub url: String,
    pub cached_at: Option<u64>,  // Timestamp of current cached version, if any
}
```

Or via a standalone function:

```rust
pub fn last_certified_at(path: &str) -> Option<u64>;
```

### Migration Path

The existing `HandlerFn` returns `HttpResponse` directly. Introducing `HandlerResult` is a breaking change. Options:

1. **New handler type alongside existing:** Support both `fn(...) -> HttpResponse` and `fn(...) -> HandlerResult`, with the former being sugar for `HandlerResult::Response(...)`.
2. **Implement `From<HttpResponse> for HandlerResult`:** So existing handlers returning `HttpResponse` work without changes via the `Into` trait.
3. **Feature gate:** Only available behind a `features = ["conditional-regen"]` flag.

Option 2 is the smoothest migration path:

```rust
impl From<DynamicResponse> for HandlerResult {
    fn from(resp: DynamicResponse) -> Self {
        HandlerResult::Response(resp)
    }
}
```

## Files to Modify

- `src/lib.rs` — Handle `HandlerResult::NotModified` in the update call path; skip recertification
- `src/assets.rs` — Provide `last_certified_at(path)` query; optionally reset TTL on NotModified
- `src/router.rs` — Update handler type to support `HandlerResult` return type

## Acceptance Criteria

- [ ] Handlers can return `HandlerResult::NotModified` to skip regeneration
- [ ] `NotModified` preserves the existing cached response and certification proof
- [ ] `NotModified` resets the TTL timer if TTL-based caching is active
- [ ] `last_certified_at(path)` returns the timestamp of the current cached version
- [ ] Handlers returning `DynamicResponse` directly still work (via `From` impl)
- [ ] No hash tree or root hash updates occur on `NotModified`
- [ ] Existing handlers that don't use `HandlerResult` are unaffected
