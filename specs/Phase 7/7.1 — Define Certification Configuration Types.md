# 7.1 — Define Certification Configuration Types

**Phase:** 7 — Configurable Certification Modes  
**Priority:** Critical  
**Status:** Not started

## Problem

The library currently has no way to configure HTTP certification granularity per-asset or per-route. All static assets use `ic-asset-certification` which internally hardcodes response-only certification. Dynamic routes have no configuration option — they always use response-only certification via `certify_dynamic_response()`. This prevents users from:

- Skipping certification for public/unauthenticated endpoints (performance optimization)
- Using full certification for authenticated API endpoints (security requirement)
- Configuring which headers and query parameters participate in certification

## Objective

Create a type system that allows configuring certification mode at three levels:
1. Per-asset group during initialization (via `certify_assets()`)
2. Per-route at handler definition (via attribute or configuration)
3. Runtime control (allow handlers to decide certification strategy)

## Specification

### Design Rationale: Enum + Builder Pattern

IC HTTP certification has three fundamental modes:
- **Skip** — No certification, fastest, use for public data
- **Response-only** — Certify response body/status/headers only (current default)
- **Full** — Certify request (method, body, headers, query params) + response

These modes are mutually exclusive, making an enum appropriate. However, "full" certification requires configuration (which headers/query params to include), so a builder pattern is needed for that variant.

### New Types

```rust
/// Certification mode for HTTP responses.
/// 
/// Determines which parts of the HTTP request/response are hashed and certified.
#[derive(Clone, Debug)]
pub enum CertificationMode {
    /// No certification. Response is served without cryptographic verification.
    /// Fastest option. Use for public endpoints where tampering risk is acceptable.
    Skip,
    
    /// Only the response is certified. Request details are not verified.
    /// Good for static assets where response depends only on URL path.
    ResponseOnly(ResponseOnlyConfig),
    
    /// Both request and response are certified.
    /// Required when response depends on request headers (e.g., Authorization, Accept).
    Full(FullConfig),
}

impl CertificationMode {
    /// Convenience constructor for skip mode.
    pub fn skip() -> Self {
        Self::Skip
    }
    
    /// Convenience constructor for response-only with default config.
    pub fn response_only() -> Self {
        Self::ResponseOnly(ResponseOnlyConfig::default())
    }
}

impl Default for CertificationMode {
    fn default() -> Self {
        Self::response_only()
    }
}

/// Configuration for response-only certification.
#[derive(Clone, Debug)]
pub struct ResponseOnlyConfig {
    /// Response headers to include in certification hash.
    /// Headers not listed here are excluded from the certification.
    /// Use `vec!["*"]` to include all headers (not recommended).
    pub include_headers: Vec<String>,
    
    /// Response headers to explicitly exclude from certification.
    /// Applied after include_headers. Useful when include_headers is ["*"].
    pub exclude_headers: Vec<String>,
}

impl Default for ResponseOnlyConfig {
    fn default() -> Self {
        Self {
            // By default, exclude headers that change between requests or are set by intermediaries
            include_headers: vec!["*".to_string()],
            exclude_headers: vec![
                "date".to_string(),
                "ic-certificate".to_string(),
                "ic-certificate-expression".to_string(),
            ],
        }
    }
}

/// Configuration for full request+response certification.
///
/// In full mode, the request method and body are **always** certified by
/// `ic-http-certification` — there is no opt-out. The configurable parts
/// are which request headers and query parameters participate in the
/// certification hash.
#[derive(Clone, Debug)]
pub struct FullConfig {
    /// Request headers to include in certification.
    /// Only these headers are hashed; others are ignored.
    pub request_headers: Vec<String>,
    
    /// Query parameters to include in certification.
    /// Only these params affect the certified response.
    pub query_params: Vec<String>,
    
    /// Response certification configuration.
    pub response: ResponseOnlyConfig,
}

impl Default for FullConfig {
    fn default() -> Self {
        Self {
            request_headers: vec![], // No headers by default (opt-in for security)
            query_params: vec![],     // No query params by default
            response: ResponseOnlyConfig::default(),
        }
    }
}

impl FullConfig {
    /// Builder-style constructor.
    pub fn builder() -> FullConfigBuilder {
        FullConfigBuilder::default()
    }
}

/// Builder for FullConfig to enable ergonomic construction.
#[derive(Default)]
pub struct FullConfigBuilder {
    request_headers: Vec<String>,
    query_params: Vec<String>,
    include_response_headers: Vec<String>,
    exclude_response_headers: Vec<String>,
}

impl FullConfigBuilder {
    pub fn with_request_headers(mut self, headers: &[&str]) -> Self {
        self.request_headers = headers.iter().map(|s| s.to_lowercase()).collect();
        self
    }
    
    pub fn with_query_params(mut self, params: &[&str]) -> Self {
        self.query_params = params.iter().map(|s| s.to_string()).collect();
        self
    }
    
    pub fn with_response_headers(mut self, headers: &[&str]) -> Self {
        self.include_response_headers = headers.iter().map(|s| s.to_lowercase()).collect();
        self
    }
    
    pub fn excluding_response_headers(mut self, headers: &[&str]) -> Self {
        self.exclude_response_headers = headers.iter().map(|s| s.to_lowercase()).collect();
        self
    }
    
    pub fn build(self) -> FullConfig {
        FullConfig {
            request_headers: self.request_headers,
            query_params: self.query_params,
            response: ResponseOnlyConfig {
                include_headers: if self.include_response_headers.is_empty() {
                    vec!["*".to_string()]
                } else {
                    self.include_response_headers
                },
                exclude_headers: self.exclude_response_headers,
            },
        }
    }
}
```

### Preset for Authenticated APIs

Most routes will use the default `ResponseOnly` mode. The only common deviation is authenticated APIs that need to certify the `Authorization` header:

```rust
impl CertificationMode {
    /// Authenticated API: full certification with Authorization header.
    /// 
    /// Use this when the response depends on who is making the request.
    /// Different Authorization headers will produce different certified responses.
    pub fn authenticated() -> Self {
        Self::Full(
            FullConfig::builder()
                .with_request_headers(&["authorization"])
                .with_response_headers(&["content-type"])
                .build()
        )
    }
}
```

**Usage:**
```rust
// Default (ResponseOnly) — appropriate for 90% of routes
certify_assets(&include_dir!("assets"));

// Skip certification — for health checks, public status pages
certify_assets_with_mode(&include_dir!("public"), CertificationMode::skip());

// Authenticated API — convenience preset for Full with Authorization header
certify_assets_with_mode(&api_dir, CertificationMode::authenticated());

// Custom Full configuration — explicit control over which headers/params
certify_assets_with_mode(
    &dir,
    CertificationMode::Full(
        FullConfig::builder()
            .with_request_headers(&["accept"])  // Content negotiation
            .build()
    )
);
```

These constructors map 1:1 with the `#[route]` macro presets (see spec 7.4):

| Constructor | Macro preset | Mode |
|---|---|---|
| `CertificationMode::skip()` | `"skip"` | `Skip` |
| `CertificationMode::response_only()` | `"response_only"` | `ResponseOnly` (default) |
| `CertificationMode::authenticated()` | `"authenticated"` | `Full` with Authorization header |
| `CertificationMode::Full(FullConfig::builder()...build())` | `custom(...)` | `Full` with explicit config |

### Header Name Normalization

HTTP header names are case-insensitive. All header names in configuration are normalized to lowercase internally to avoid mismatch issues:

```rust
// These are equivalent:
.with_request_headers(&["Authorization", "Accept"])
.with_request_headers(&["authorization", "accept"])
```

### Integration with ic-http-certification

The `CertificationMode` enum maps directly to `ic-http-certification` APIs:

| Mode | CEL Expression | HttpCertification Method |
|------|----------------|--------------------------|
| `Skip` | `DefaultCelBuilder::skip_certification()` | `HttpCertification::skip()` |
| `ResponseOnly` | `DefaultCelBuilder::response_only_certification()` | `HttpCertification::response_only()` |
| `Full` | `DefaultCelBuilder::full_certification()` | `HttpCertification::full()` |

The configuration structs (`ResponseOnlyConfig`, `FullConfig`) translate to CEL expression parameters.

## Files to Create

- New file: `src/certification.rs` — Core types and presets

## Files to Modify

- `src/lib.rs` — Export new types
- `Cargo.toml` — Ensure `ic-http-certification` features are available

## Acceptance Criteria

- [ ] `CertificationMode` enum with `Skip`, `ResponseOnly`, `Full` variants
- [ ] `ResponseOnlyConfig` with `include_headers` and `exclude_headers`
- [ ] `FullConfig` with request headers, query params, and response config
- [ ] `FullConfigBuilder` for ergonomic construction
- [ ] Header names normalized to lowercase internally
- [ ] Preset constructor: `authenticated()` (the only common deviation from default)
- [ ] All types derive `Clone` and `Debug`
- [ ] Default impls follow principle of least privilege (opt-in for sensitive data)
- [ ] Types are documented with rustdoc
- [ ] Unit tests for builder pattern and preset configurations
