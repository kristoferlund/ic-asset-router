# 7.2 — Build Asset Router

**Phase:** 7 — Configurable Certification Modes  
**Priority:** Critical  
**Status:** Not started

## Problem

The library currently depends on `ic-asset-certification::AssetRouter`, which has a critical limitation: **all assets must use the same CEL expression** (certification mode). This prevents us from:

- Skipping certification for specific assets (public health checks)
- Using full certification for assets that depend on request headers
- Configuring certification on a per-asset basis

Additionally, the external `AssetRouter` couples asset storage, certification, and serving into one opaque component, making it difficult to extend or customize behavior.

**Current workaround complexity:** The library maintains two separate sources of truth for dynamic assets:
- `DYNAMIC_CACHE` (HashMap) — Tracks metadata (certified_at timestamp, TTL) for dynamic assets
- `ASSET_ROUTER` (external) — Stores the actual certified response and tree entry

This requires checking both sources during invalidation and creates coordination overhead. For example, `invalidate_path()` must check DYNAMIC_CACHE first to determine if an asset is dynamic, then delete from ASSET_ROUTER separately.

## Objective

Build our own asset router that:
1. Replaces `ic-asset-certification::AssetRouter`
2. Supports per-asset certification configuration
3. Uses `ic-http-certification` primitives directly
4. Maintains feature parity (encoding negotiation, fallbacks, aliases)
5. Integrates cleanly with existing thread-local state
6. **Unifies asset metadata and certification into a single source of truth**, eliminating the need for separate `DYNAMIC_CACHE` and reducing coordination complexity

## Specification

### Design Rationale

The router will be a **thin layer** over `ic-http-certification` primitives:
- `HttpCertificationTree` — shared merkle tree (already exists in our codebase)
- `HttpCertification` — creates certifications (skip/response_only/full)
- `DefaultCelBuilder` — builds CEL expressions
- `add_v2_certificate_header` — injects certificate into responses

This approach:
- Gives us full control over certification per asset
- Avoids upstream limitations
- Is educational — we understand the stack deeply
- Is maintainable — ~300-400 lines vs. opaque external dependency

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                       AssetRouter                           │
├─────────────────────────────────────────────────────────────┤
│  assets: HashMap<String, CertifiedAsset>                    │
│  aliases: HashMap<String, String>  (alias → canonical)      │
│  fallbacks: Vec<(String, String)>  (scope → path, sorted)   │
│  tree: Rc<RefCell<HttpCertificationTree>>                   │
├─────────────────────────────────────────────────────────────┤
│  certify_asset(path, content, config)                       │
│  certify_dynamic_asset(path, request, response, config)     │
│  serve_asset(request) -> Option<(Response, Witness, Path)>  │
│  delete_asset(path)                                         │
│  get_asset(path) -> Option<&CertifiedAsset>                 │
│  root_hash() -> [u8; 32]                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     CertifiedAsset                          │
├─────────────────────────────────────────────────────────────┤
│  content: Vec<u8>                                           │
│  content_type: String                                       │
│  encodings: HashMap<Encoding, Vec<u8>>                      │
│  headers: Vec<HeaderField>                                  │
│  certification_mode: CertificationMode                      │
│  tree_entry: HttpCertificationTreeEntry                     │
└─────────────────────────────────────────────────────────────┘
```

### Core Types

```rust
/// Asset encoding variants supported by the router.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum AssetEncoding {
    Identity,  // No encoding
    Gzip,
    Brotli,
}

impl AssetEncoding {
    /// Content-Encoding header value.
    pub fn as_str(&self) -> &'static str {
        match self {
            AssetEncoding::Identity => "identity",
            AssetEncoding::Gzip => "gzip",
            AssetEncoding::Brotli => "br",
        }
    }
}

/// A certified asset with all its metadata and certification info.
///
/// Note: this struct intentionally does NOT derive `Clone`.
/// `HttpCertificationTreeEntry` is a reference into the tree and should
/// not be duplicated. Aliases are stored as path → canonical-path mappings
/// in the router, not as cloned asset entries.
pub struct CertifiedAsset {
    /// Raw content (for Identity encoding).
    pub content: Vec<u8>,
    
    /// Encoded variants (Gzip, Brotli).
    pub encodings: HashMap<AssetEncoding, Vec<u8>>,
    
    /// MIME type (e.g., "text/html").
    pub content_type: String,
    
    /// Additional headers to include in response.
    pub headers: Vec<HeaderField>,
    
    /// Certification mode for this asset.
    pub certification_mode: CertificationMode,
    
    /// Pre-computed CEL expression string.
    pub cel_expression: String,
    
    /// Tree entry for generating witnesses.
    pub tree_entry: HttpCertificationTreeEntry,
    
    /// Whether this asset can serve as a fallback for paths in its scope.
    pub fallback_scope: Option<String>,
    
    /// Additional paths that alias to this asset.
    pub aliases: Vec<String>,
    
    /// Timestamp (nanoseconds) when the asset was certified.
    /// Enables TTL-based cache invalidation.
    pub certified_at: u64,
    
    /// Optional TTL for cache invalidation.
    /// `None` means the asset never expires (static assets).
    /// `Some(duration)` enables TTL-based invalidation (dynamic assets).
    pub ttl: Option<Duration>,
}

impl CertifiedAsset {
    /// Returns true if this asset has a TTL (i.e., is a dynamic asset).
    pub fn is_dynamic(&self) -> bool {
        self.ttl.is_some()
    }
    
    /// Check if the asset has expired based on current time.
    pub fn is_expired(&self, now_ns: u64) -> bool {
        match self.ttl {
            None => false,
            Some(ttl) => {
                let expiry_ns = self.certified_at.saturating_add(ttl.as_nanos() as u64);
                now_ns >= expiry_ns
            }
        }
    }
}

/// Configuration for certifying an asset.
pub struct AssetCertificationConfig {
    /// Certification mode (determines CEL expression).
    pub mode: CertificationMode,
    
    /// MIME type. Auto-detected from path if not provided.
    pub content_type: Option<String>,
    
    /// Additional headers.
    pub headers: Vec<HeaderField>,
    
    /// Available encodings (content should be pre-compressed).
    pub encodings: Vec<(AssetEncoding, Vec<u8>)>,
    
    /// Fallback scope (e.g., "/" for SPA fallback).
    pub fallback_for: Option<String>,
    
    /// Path aliases.
    pub aliases: Vec<String>,
    
    /// Timestamp (nanoseconds) when the asset was certified.
    /// Use `ic_cdk::api::time()` for the current time.
    pub certified_at: u64,
    
    /// Optional TTL for cache invalidation.
    /// `None` means the asset never expires (static assets).
    /// `Some(duration)` enables TTL-based invalidation (dynamic assets).
    pub ttl: Option<Duration>,
}

impl Default for AssetCertificationConfig {
    fn default() -> Self {
        Self {
            mode: CertificationMode::response_only(),
            content_type: None,
            headers: vec![],
            encodings: vec![],
            fallback_for: None,
            aliases: vec![],
            certified_at: 0,
            ttl: None,
        }
    }
}

/// Asset router supporting per-asset certification modes.
pub struct AssetRouter {
    /// Certified assets by canonical path.
    assets: HashMap<String, CertifiedAsset>,
    
    /// Alias path → canonical path. Aliases are not separate asset entries;
    /// they resolve to the canonical path which is then looked up in `assets`.
    aliases: HashMap<String, String>,
    
    /// Shared certification tree.
    tree: Rc<RefCell<HttpCertificationTree>>,
    
    /// Fallback assets by scope, sorted by scope length descending
    /// so that longest-prefix match wins.
    fallbacks: Vec<(String, String)>, // (scope, asset_path), sorted longest-first
}

impl AssetRouter {
    /// Create a new router with the given certification tree.
    pub fn with_tree(tree: Rc<RefCell<HttpCertificationTree>>) -> Self {
        Self {
            assets: HashMap::new(),
            aliases: HashMap::new(),
            tree,
            fallbacks: Vec::new(),
        }
    }
    
    /// Certify a single asset (static or dynamic).
    ///
    /// For static assets, use `Skip` or `ResponseOnly` mode.
    /// For dynamic assets, any mode is valid including `Full` —
    /// the caller provides the request when certifying via
    /// `certify_dynamic_asset`.
    pub fn certify_asset(
        &mut self,
        path: &str,
        content: Vec<u8>,
        config: AssetCertificationConfig,
    ) -> Result<(), AssetRouterError> {
        // Implementation details below
    }
    
    /// Certify a dynamic asset with Full mode, where the request is
    /// available and required for certification.
    ///
    /// This is the entry point used by `http_request_update` for routes
    /// configured with `CertificationMode::Full`.
    pub fn certify_dynamic_asset(
        &mut self,
        path: &str,
        request: &HttpRequest,
        response: &HttpResponse<'static>,
        config: AssetCertificationConfig,
    ) -> Result<(), AssetRouterError> {
        // Implementation details below
    }
    
    /// Serve an asset for the given request.
    ///
    /// Returns `None` if no matching asset is found.
    /// Returns the response, the witness (merkle proof), and the
    /// expression path needed to construct the `ic-certificate` header.
    ///
    /// The caller is responsible for calling `add_v2_certificate_header`
    /// with the returned witness, expression path, and the IC data
    /// certificate to produce the final servable response.
    pub fn serve_asset(
        &self,
        request: &HttpRequest,
    ) -> Option<(HttpResponse<'static>, HashTree, Vec<String>)> {
        // Implementation details below
    }
    
    /// Delete an asset by path (canonical or alias).
    pub fn delete_asset(&mut self, path: &str) {
        // Resolve alias to canonical path
        let canonical = self.aliases.remove(path)
            .unwrap_or_else(|| path.to_string());
        
        if let Some(asset) = self.assets.remove(&canonical) {
            // Remove from tree
            self.tree.borrow_mut().delete(&asset.tree_entry);
            // Remove from fallbacks
            self.fallbacks.retain(|(_, v)| v != &canonical);
            // Remove any aliases pointing to this canonical path
            self.aliases.retain(|_, v| v != &canonical);
        }
    }
    
    /// Get the root hash of the certification tree.
    pub fn root_hash(&self) -> [u8; 32] {
        self.tree.borrow().root_hash()
    }
    
    /// Check if an asset exists at the given path (canonical or alias).
    pub fn contains_asset(&self, path: &str) -> bool {
        let canonical = self.aliases.get(path)
            .map(|s| s.as_str())
            .unwrap_or(path);
        self.assets.contains_key(canonical)
    }
    
    /// Get a reference to a certified asset by path (canonical or alias).
    pub fn get_asset(&self, path: &str) -> Option<&CertifiedAsset> {
        let canonical = self.aliases.get(path)
            .map(|s| s.as_str())
            .unwrap_or(path);
        self.assets.get(canonical)
    }
    
    /// Get a mutable reference to a certified asset by path.
    pub fn get_asset_mut(&mut self, path: &str) -> Option<&mut CertifiedAsset> {
        let canonical = self.aliases.get(path)
            .map(|s| s.as_str())
            .unwrap_or(path)
            .to_string();
        self.assets.get_mut(&canonical)
    }
}
```

### Implementation: certify_asset

`certify_asset` handles `Skip` and `ResponseOnly` modes (no request needed).
For `Full` mode, use `certify_dynamic_asset` which takes a request.

```rust
impl AssetRouter {
    pub fn certify_asset(
        &mut self,
        path: &str,
        content: Vec<u8>,
        config: AssetCertificationConfig,
    ) -> Result<(), AssetRouterError> {
        // Full mode requires a request — use certify_dynamic_asset instead
        if matches!(&config.mode, CertificationMode::Full(_)) {
            return Err(AssetRouterError::FullModeRequiresRequest);
        }
        
        // 1. Determine content type
        let content_type = config.content_type
            .unwrap_or_else(|| guess_mime_type(path));
        
        // 2. Build CEL expression based on certification mode
        let cel_expr = build_cel_expression(&config.mode);
        
        // 3. Create response for certification
        let mut response = HttpResponse::builder()
            .with_status_code(200)
            .with_headers(vec![
                ("content-type".to_string(), content_type.clone()),
                (CERTIFICATE_EXPRESSION_HEADER_NAME.to_string(), cel_expr.clone()),
            ])
            .with_body(content.clone())
            .build();
        
        // Add additional headers
        for (name, value) in &config.headers {
            response.add_header((name.clone(), value.clone()));
        }
        
        // 4. Create certification based on mode
        let certification = match &config.mode {
            CertificationMode::Skip => {
                HttpCertification::skip()
            }
            CertificationMode::ResponseOnly(_) => {
                HttpCertification::response_only(&cel_expr, &response, None)
                    .map_err(|e| AssetRouterError::CertificationFailed(e.to_string()))?
            }
            CertificationMode::Full(_) => unreachable!(), // guarded above
        };
        
        // 5. Create tree entry and insert
        let tree_path = HttpCertificationPath::exact(path);
        let tree_entry = HttpCertificationTreeEntry::new(&tree_path, &certification);
        self.tree.borrow_mut().insert(&tree_entry);
        
        // 6. Build encodings map
        let mut encodings = HashMap::new();
        encodings.insert(AssetEncoding::Identity, content.clone());
        for (encoding, encoded_content) in config.encodings {
            encodings.insert(encoding, encoded_content);
        }
        
        // 7. Store asset
        let asset = CertifiedAsset {
            content,
            encodings,
            content_type,
            headers: config.headers,
            certification_mode: config.mode,
            cel_expression: cel_expr,
            tree_entry,
            fallback_scope: config.fallback_for.clone(),
            aliases: config.aliases.clone(),
            certified_at: config.certified_at,
            ttl: config.ttl,
        };
        
        self.assets.insert(path.to_string(), asset);
        
        // 8. Register fallback if specified (sorted longest-first)
        if let Some(scope) = config.fallback_for {
            self.fallbacks.push((scope, path.to_string()));
            self.fallbacks.sort_by(|a, b| b.0.len().cmp(&a.0.len()));
        }
        
        // 9. Register aliases (as path mappings, not cloned assets)
        for alias in config.aliases {
            self.aliases.insert(alias, path.to_string());
        }
        
        Ok(())
    }
    
    /// Certify a dynamic asset with Full mode.
    ///
    /// Unlike `certify_asset`, this takes the original request so that
    /// request method, body, headers, and query params can participate
    /// in the certification hash.
    pub fn certify_dynamic_asset(
        &mut self,
        path: &str,
        request: &HttpRequest,
        response: &HttpResponse<'static>,
        config: AssetCertificationConfig,
    ) -> Result<(), AssetRouterError> {
        let cel_expr = build_cel_expression(&config.mode);
        
        let certification = match &config.mode {
            CertificationMode::Skip => HttpCertification::skip(),
            CertificationMode::ResponseOnly(_) => {
                HttpCertification::response_only(&cel_expr, response, None)
                    .map_err(|e| AssetRouterError::CertificationFailed(e.to_string()))?
            }
            CertificationMode::Full(_) => {
                HttpCertification::full(&cel_expr, request, response, None)
                    .map_err(|e| AssetRouterError::CertificationFailed(e.to_string()))?
            }
        };
        
        let tree_path = HttpCertificationPath::exact(path);
        let tree_entry = HttpCertificationTreeEntry::new(&tree_path, &certification);
        self.tree.borrow_mut().insert(&tree_entry);
        
        let content_type = config.content_type
            .unwrap_or_else(|| guess_mime_type(path));
        
        let asset = CertifiedAsset {
            content: response.body().to_vec(),
            encodings: HashMap::from([(AssetEncoding::Identity, response.body().to_vec())]),
            content_type,
            headers: config.headers,
            certification_mode: config.mode,
            cel_expression: cel_expr,
            tree_entry,
            fallback_scope: None,
            aliases: vec![],
            certified_at: config.certified_at,
            ttl: config.ttl,
        };
        
        self.assets.insert(path.to_string(), asset);
        Ok(())
    }
}

fn build_cel_expression(mode: &CertificationMode) -> String {
    match mode {
        CertificationMode::Skip => {
            DefaultCelBuilder::skip_certification().to_string()
        }
        CertificationMode::ResponseOnly(config) => {
            let builder = DefaultCelBuilder::response_only_certification();
            
            // Configure response header certification
            let response_cert = build_response_certification(config);
            
            builder
                .with_response_certification(response_cert)
                .build()
                .to_string()
        }
        CertificationMode::Full(config) => {
            let mut builder = DefaultCelBuilder::full_certification();
            
            // Configure request certification
            if !config.request_headers.is_empty() {
                builder = builder.with_request_headers(config.request_headers.clone());
            }
            if !config.query_params.is_empty() {
                builder = builder.with_request_query_parameters(config.query_params.clone());
            }
            
            // Configure response certification
            let response_cert = build_response_certification(&config.response);
            builder = builder.with_response_certification(response_cert);
            
            builder.build().to_string()
        }
    }
}

/// Shared helper: build DefaultResponseCertification from ResponseOnlyConfig.
fn build_response_certification(config: &ResponseOnlyConfig) -> DefaultResponseCertification {
    if config.include_headers == vec!["*"] {
        DefaultResponseCertification::response_header_exclusions(
            config.exclude_headers.clone()
        )
    } else {
        DefaultResponseCertification::certified_response_headers(
            config.include_headers.clone()
        )
    }
}

fn guess_mime_type(path: &str) -> String {
    // Use existing mime::get_mime_type or similar
    mime::get_mime_type(path).to_string()
}
```

### Implementation: serve_asset

```rust
impl AssetRouter {
    pub fn serve_asset(
        &self,
        request: &HttpRequest,
    ) -> Option<(HttpResponse<'static>, HashTree, Vec<String>)> {
        let path = request.url();
        
        // 1. Try exact match (canonical path)
        if let Some(asset) = self.assets.get(path) {
            return self.serve_matched_asset(request, asset);
        }
        
        // 2. Try alias → canonical resolution
        if let Some(canonical) = self.aliases.get(path) {
            if let Some(asset) = self.assets.get(canonical) {
                return self.serve_matched_asset(request, asset);
            }
        }
        
        // 3. Try fallback (sorted longest-first, so first match wins)
        for (scope, fallback_path) in &self.fallbacks {
            if path.starts_with(scope) {
                if let Some(asset) = self.assets.get(fallback_path) {
                    return self.serve_matched_asset(request, asset);
                }
            }
        }
        
        None
    }
    
    fn serve_matched_asset(
        &self,
        request: &HttpRequest,
        asset: &CertifiedAsset,
    ) -> Option<(HttpResponse<'static>, HashTree, Vec<String>)> {
        // 1. Select encoding based on Accept-Encoding header
        let encoding = self.select_encoding(request, asset);
        let content = asset.encodings.get(&encoding)?;
        
        // 2. Build response
        let mut response = HttpResponse::builder()
            .with_status_code(200)
            .with_headers(asset.headers.clone())
            .with_body(content.clone())
            .build();
        
        // Add Content-Encoding header if not identity
        if encoding != AssetEncoding::Identity {
            response.add_header((
                "content-encoding".to_string(),
                encoding.as_str().to_string(),
            ));
        }
        
        // 3. Handle certification based on mode
        match &asset.certification_mode {
            CertificationMode::Skip => {
                // No certification needed
                // Return empty witness and expr_path
                let empty_witness = HashTree::default();
                let empty_path = vec![];
                Some((response, empty_witness, empty_path))
            }
            _ => {
                // Generate witness from tree
                let tree = self.tree.borrow();
                let witness = tree.witness(&asset.tree_entry, request.url()).ok()?;
                let expr_path = asset.tree_entry.path.to_expr_path();
                Some((response, witness, expr_path))
            }
        }
    }
    
    fn select_encoding(
        &self,
        request: &HttpRequest,
        asset: &CertifiedAsset,
    ) -> AssetEncoding {
        // Parse Accept-Encoding header
        let accept_encoding = request.headers()
            .iter()
            .find(|(k, _)| k.eq_ignore_ascii_case("accept-encoding"))
            .map(|(_, v)| v.as_str())
            .unwrap_or("");
        
        // Check for Brotli first (preferred)
        if accept_encoding.contains("br") && asset.encodings.contains_key(&AssetEncoding::Brotli) {
            return AssetEncoding::Brotli;
        }
        
        // Check for Gzip
        if accept_encoding.contains("gzip") && asset.encodings.contains_key(&AssetEncoding::Gzip) {
            return AssetEncoding::Gzip;
        }
        
        // Fall back to identity
        AssetEncoding::Identity
    }
}
```

### Error Types

```rust
#[derive(Debug)]
pub enum AssetRouterError {
    CertificationFailed(String),
    FullModeRequiresRequest,
    AssetNotFound(String),
    DuplicatePath(String),
}

impl std::fmt::Display for AssetRouterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AssetRouterError::CertificationFailed(msg) => {
                write!(f, "Failed to create certification: {}", msg)
            }
            AssetRouterError::FullModeRequiresRequest => {
                write!(f, "Full certification mode requires a request; use certify_dynamic_asset()")
            }
            AssetRouterError::AssetNotFound(path) => {
                write!(f, "Asset not found: {}", path)
            }
            AssetRouterError::DuplicatePath(path) => {
                write!(f, "Asset already exists at path: {}", path)
            }
        }
    }
}

impl std::error::Error for AssetRouterError {}
```

### Migration from ic-asset-certification

#### Thread-local state

```rust
// OLD:
use ic_asset_certification::{AssetRouter, ...};

thread_local! {
    static ASSET_ROUTER: RefCell<AssetRouter<'static>> = ...;
    static DYNAMIC_CACHE: RefCell<HashMap<String, CachedDynamicAsset>> = ...;
}

// NEW:
use crate::asset_router::AssetRouter;

thread_local! {
    // Single source of truth — DYNAMIC_CACHE is eliminated
    static ASSET_ROUTER: RefCell<AssetRouter> = ...;
}
```

#### serve_asset API change

The old external `AssetRouter::serve_asset(&cert, &req)` took the IC data
certificate and returned a fully-formed response with `ic-certificate` header.

The new router returns `(response, witness, expr_path)` — the caller must
attach the certificate header using `add_v2_certificate_header`:

```rust
// OLD:
let response = asset_router.serve_asset(&data_certificate, &request)?;

// NEW:
let (mut response, witness, expr_path) = asset_router.serve_asset(&request)?;
add_v2_certificate_header(
    &data_certificate,
    &mut response,
    &witness,
    &expr_path,
);
```

This separation is intentional — it keeps the router independent of the IC
runtime (`data_certificate()` is only available in query calls, not in the
router itself).

#### certify_assets function

```rust
pub fn certify_assets_with_mode(
    asset_dir: &Dir<'static>,
    mode: CertificationMode,
) {
    // See spec 7.3 for full implementation
}
```

### Unification Benefit: Eliminating DYNAMIC_CACHE

With the new `AssetRouter`, the `DYNAMIC_CACHE` thread-local becomes unnecessary. Here's the before/after comparison:

**Before (with external AssetRouter + DYNAMIC_CACHE):**
```rust
pub fn invalidate_path(path: &str) {
    // Must check DYNAMIC_CACHE first to know if it's dynamic
    let was_dynamic = DYNAMIC_CACHE.with(|dc| dc.borrow_mut().remove(path).is_some());
    if was_dynamic {
        // Then delete from separate ASSET_ROUTER
        ASSET_ROUTER.with_borrow_mut(|asset_router| {
            asset_router.delete_assets_by_path(vec![path]);
            certified_data_set(asset_router.root_hash());
        });
    }
}
```

**After (unified AssetRouter):**
```rust
pub fn invalidate_path(path: &str) {
    ASSET_ROUTER.with_borrow_mut(|router| {
        // Single source of truth - asset knows if it's dynamic
        if let Some(asset) = router.get_asset(path) {
            if asset.is_dynamic() {
                router.delete_asset(path);
                certified_data_set(router.root_hash());
            }
        }
    });
}
```

**Benefits:**
- Single source of truth for all asset metadata
- No coordination overhead between two data structures
- Simpler invalidation logic
- Easier to reason about asset lifecycle
- Reduced thread-local storage

## Files to Create

- New file: `src/asset_router.rs` — Asset router implementation
- New file: `src/asset_router/types.rs` — Types and configuration structs  
- New file: `src/asset_router/encoding.rs` — Encoding negotiation logic

## Files to Modify

- `src/lib.rs` — Replace `ic-asset-certification::AssetRouter` with our `AssetRouter`
- `src/assets.rs` — Update `certify_assets` to use our router
- `Cargo.toml` — Remove `ic-asset-certification` dependency (or make optional)

## Acceptance Criteria

### Functional
- [ ] Asset router supports all three certification modes per asset
- [ ] Response-only certification works identically to current implementation
- [ ] Skip certification adds asset to tree but serves without certificate header
- [ ] Full certification via `certify_dynamic_asset` works with request+response
- [ ] `certify_asset` with Full mode returns `FullModeRequiresRequest` error
- [ ] Encoding negotiation works (Identity, Gzip, Brotli)
- [ ] Fallback/scope matching works for SPAs (longest-prefix wins)
- [ ] Path aliases resolve correctly (get, contains, serve, delete)
- [ ] Asset deletion updates tree, aliases, and fallbacks correctly
- [ ] Root hash updates correctly after each certification and deletion
- [ ] `CertifiedAsset` includes `certified_at` and `ttl` fields
- [ ] `is_dynamic()` and `is_expired()` methods work correctly
- [ ] `DYNAMIC_CACHE` thread-local is removed (unified into AssetRouter)
- [ ] Invalidation API works with unified asset router
- [ ] All existing tests pass without modification
- [ ] Code is well-documented with rustdoc
- [ ] Error types provide clear messages

### Test coverage

Every public method on `AssetRouter` must have unit tests. At minimum:

- [ ] `certify_asset` — ResponseOnly mode succeeds
- [ ] `certify_asset` — Skip mode succeeds
- [ ] `certify_asset` — Full mode returns `FullModeRequiresRequest`
- [ ] `certify_dynamic_asset` — Full mode succeeds with request+response
- [ ] `certify_dynamic_asset` — ResponseOnly and Skip modes also work
- [ ] `serve_asset` — exact path match returns correct response
- [ ] `serve_asset` — alias path resolves to canonical asset
- [ ] `serve_asset` — fallback match when no exact/alias match
- [ ] `serve_asset` — longest-prefix fallback wins over shorter
- [ ] `serve_asset` — returns `None` when no match at all
- [ ] `serve_asset` — Skip mode response has no witness/expr_path
- [ ] `serve_asset` — encoding negotiation (Brotli > Gzip > Identity)
- [ ] `delete_asset` — removes asset, tree entry, aliases, and fallback
- [ ] `delete_asset` — via alias resolves and removes canonical
- [ ] `delete_asset` — nonexistent path is a no-op
- [ ] `get_asset` / `contains_asset` — via canonical and alias paths
- [ ] `get_asset` — nonexistent returns `None`
- [ ] `root_hash` — changes after certify and after delete
- [ ] Re-certification of same path (delete + certify) produces new hash
- [ ] Mode switching (certify with ResponseOnly, delete, re-certify with Skip)
- [ ] `is_dynamic` — `true` when `ttl.is_some()`, `false` otherwise
- [ ] `is_expired` — respects `certified_at` + `ttl` vs current time
- [ ] `is_expired` — static assets (`ttl: None`) never expire
