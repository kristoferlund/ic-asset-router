# 7.6 — Integration Tests for Certification Modes

**Phase:** 7 — Configurable Certification Modes  
**Priority:** Medium  
**Status:** Not started

## Problem

HTTP certification is security-critical code that must be thoroughly tested. The new certification mode configuration adds complexity that needs automated testing to ensure:

- Correct CEL expressions are generated for each mode
- Certification verification passes for valid responses
- Certification verification fails for tampered responses
- Different modes don't interfere with each other
- Edge cases (empty configs, special characters in headers) are handled

## Objective

Create comprehensive test coverage for certification modes using PocketIC for end-to-end verification.

## Specification

### Test Categories

#### 1. Unit Tests (Internal)

Test individual components without IC runtime:

##### 1a. CEL expression generation

```rust
// src/certification.rs tests

#[test]
fn test_cel_expression_skip() {
    let mode = CertificationMode::Skip;
    let cel = build_cel_expression(&mode);
    assert!(cel.contains("skip"));
}

#[test]
fn test_cel_expression_response_only_default() {
    let mode = CertificationMode::response_only();
    let cel = build_cel_expression(&mode);
    // Should contain response certification but NOT request certification
    assert!(cel.contains("response_certification"));
    assert!(!cel.contains("request_certification"));
}

#[test]
fn test_cel_expression_response_only_with_explicit_headers() {
    let config = ResponseOnlyConfig {
        include_headers: vec!["content-type".to_string(), "etag".to_string()],
        exclude_headers: vec![],
    };
    let mode = CertificationMode::ResponseOnly(config);
    let cel = build_cel_expression(&mode);
    assert!(cel.contains("content-type"));
    assert!(cel.contains("etag"));
}

#[test]
fn test_cel_expression_response_only_with_exclusions() {
    let config = ResponseOnlyConfig {
        include_headers: vec!["*".to_string()],
        exclude_headers: vec!["date".to_string(), "x-custom".to_string()],
    };
    let mode = CertificationMode::ResponseOnly(config);
    let cel = build_cel_expression(&mode);
    // Should use exclusion-based certification
    assert!(cel.contains("response_certification"));
}

#[test]
fn test_cel_expression_full_with_headers_and_params() {
    let config = FullConfig::builder()
        .with_request_headers(&["authorization"])
        .with_query_params(&["page"])
        .build();
    let mode = CertificationMode::Full(config);
    let cel = build_cel_expression(&mode);
    // Verify CEL includes request certification
    assert!(cel.contains("request_certification"));
    assert!(cel.contains("authorization"));
    assert!(cel.contains("page"));
}

#[test]
fn test_cel_expression_full_empty_config() {
    // Full mode with no headers/params should still produce valid CEL
    let config = FullConfig::default();
    let mode = CertificationMode::Full(config);
    let cel = build_cel_expression(&mode);
    assert!(cel.contains("request_certification"));
    // Should not panic or produce empty string
    assert!(!cel.is_empty());
}
```

##### 1b. Type constructors and presets

```rust
#[test]
fn test_default_is_response_only() {
    let mode = CertificationMode::default();
    assert!(matches!(mode, CertificationMode::ResponseOnly(_)));
}

#[test]
fn test_skip_constructor() {
    let mode = CertificationMode::skip();
    assert!(matches!(mode, CertificationMode::Skip));
}

#[test]
fn test_response_only_constructor() {
    let mode = CertificationMode::response_only();
    match mode {
        CertificationMode::ResponseOnly(config) => {
            assert_eq!(config.include_headers, vec!["*".to_string()]);
            assert!(config.exclude_headers.contains(&"date".to_string()));
            assert!(config.exclude_headers.contains(&"ic-certificate".to_string()));
            assert!(config.exclude_headers.contains(&"ic-certificate-expression".to_string()));
        }
        _ => panic!("Expected ResponseOnly"),
    }
}

#[test]
fn test_authenticated_preset() {
    let mode = CertificationMode::authenticated();
    match mode {
        CertificationMode::Full(config) => {
            assert!(config.request_headers.contains(&"authorization".to_string()));
            assert_eq!(config.response.include_headers, vec!["content-type".to_string()]);
        }
        _ => panic!("Expected Full"),
    }
}
```

##### 1c. FullConfigBuilder

```rust
#[test]
fn test_builder_all_options() {
    let config = FullConfig::builder()
        .with_request_headers(&["authorization", "accept"])
        .with_query_params(&["page", "limit"])
        .with_response_headers(&["content-type", "etag"])
        .excluding_response_headers(&["date"])
        .build();
    
    assert_eq!(config.request_headers, vec!["authorization", "accept"]);
    assert_eq!(config.query_params, vec!["page", "limit"]);
    assert_eq!(config.response.include_headers, vec!["content-type", "etag"]);
    assert_eq!(config.response.exclude_headers, vec!["date"]);
}

#[test]
fn test_builder_no_options() {
    let config = FullConfig::builder().build();
    assert!(config.request_headers.is_empty());
    assert!(config.query_params.is_empty());
    // Empty response headers → defaults to wildcard
    assert_eq!(config.response.include_headers, vec!["*".to_string()]);
}

#[test]
fn test_builder_partial_options() {
    let config = FullConfig::builder()
        .with_request_headers(&["authorization"])
        .build();
    assert_eq!(config.request_headers, vec!["authorization"]);
    assert!(config.query_params.is_empty());
}
```

##### 1d. Header name normalization

```rust
#[test]
fn test_header_name_normalization_request() {
    let config = FullConfig::builder()
        .with_request_headers(&["Authorization", "ACCEPT", "X-Custom-Header"])
        .build();
    assert!(config.request_headers.contains(&"authorization".to_string()));
    assert!(config.request_headers.contains(&"accept".to_string()));
    assert!(config.request_headers.contains(&"x-custom-header".to_string()));
}

#[test]
fn test_header_name_normalization_response() {
    let config = FullConfig::builder()
        .with_response_headers(&["Content-Type", "ETag"])
        .build();
    assert!(config.response.include_headers.contains(&"content-type".to_string()));
    assert!(config.response.include_headers.contains(&"etag".to_string()));
}

#[test]
fn test_query_params_not_normalized() {
    // Query params are case-sensitive, should NOT be lowercased
    let config = FullConfig::builder()
        .with_query_params(&["Page", "userId"])
        .build();
    assert!(config.query_params.contains(&"Page".to_string()));
    assert!(config.query_params.contains(&"userId".to_string()));
}
```

#### 2. Integration Tests (PocketIC)

Test full HTTP certification flow with PocketIC:

```rust
// tests/certification_modes.rs

use pocket_ic::PocketIc;

#[test]
fn test_skip_certification_serves_without_certificate() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    
    // Deploy canister with skip certification route
    deploy_with_skip_route(&pic, canister);
    
    // Query route
    let response = query(&pic, canister, "/public/health");
    
    // Response should not have IC-Certificate header
    assert!(!response.headers.contains_key("ic-certificate"));
    assert_eq!(response.status, 200);
}

#[test]
fn test_response_only_certification_verifies() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    
    deploy_with_static_assets(&pic, canister);
    
    // Query static asset
    let response = query(&pic, canister, "/style.css");
    
    // Should have certificate
    assert!(response.headers.contains_key("ic-certificate"));
    
    // Verify certificate is valid
    let result = verify_response(&pic, canister, &response);
    assert!(result.is_valid);
}

#[test]
fn test_full_certification_with_auth_header() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    
    deploy_with_auth_api(&pic, canister);
    
    // Query with Authorization header
    let response = query_with_header(
        &pic, 
        canister, 
        "/api/user",
        vec![("Authorization", "Bearer token123")]
    );
    
    // Should be certified
    assert!(response.headers.contains_key("ic-certificate"));
    
    // Verification should succeed with correct header
    let result = verify_response_with_headers(
        &pic, 
        canister, 
        &response,
        vec![("Authorization", "Bearer token123")]
    );
    assert!(result.is_valid);
    
    // Verification should fail with different header (simulated tampering)
    let result_tampered = verify_response_with_headers(
        &pic,
        canister,
        &response,
        vec![("Authorization", "Bearer different")]
    );
    assert!(!result_tampered.is_valid);
}

#[test]
fn test_full_certification_with_query_params() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    
    deploy_with_paginated_api(&pic, canister);
    
    // Query with page param
    let response = query(&pic, canister, "/api/items?page=1&limit=10");
    
    // Certificate should be specific to these params
    let result = verify_response_with_query(
        &pic,
        canister,
        &response,
        "/api/items?page=1&limit=10"
    );
    assert!(result.is_valid);
    
    // Different params should not verify against this certificate
    let result_wrong = verify_response_with_query(
        &pic,
        canister,
        &response,
        "/api/items?page=2&limit=10"
    );
    assert!(!result_wrong.is_valid);
}

#[test]
fn test_mixed_certification_modes() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    
    // Deploy with all three modes
    deploy_with_mixed_modes(&pic, canister);
    
    // Each route should work with its configured mode
    let skip_response = query(&pic, canister, "/public/health");
    assert!(!skip_response.headers.contains_key("ic-certificate"));
    
    let static_response = query(&pic, canister, "/static/style.css");
    assert!(static_response.headers.contains_key("ic-certificate"));
    
    let api_response = query(&pic, canister, "/api/data");
    assert!(api_response.headers.contains_key("ic-certificate"));
}
```

#### 3. AssetRouter Unit Tests

These test the router's core operations without IC runtime:

```rust
// src/asset_router.rs tests (or tests/asset_router.rs)

#[test]
fn test_certify_asset_response_only() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let result = router.certify_asset("/style.css", b"body{}".to_vec(),
        AssetCertificationConfig::default());
    assert!(result.is_ok());
    assert!(router.contains_asset("/style.css"));
}

#[test]
fn test_certify_asset_skip() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config = AssetCertificationConfig {
        mode: CertificationMode::skip(),
        ..Default::default()
    };
    let result = router.certify_asset("/health", b"ok".to_vec(), config);
    assert!(result.is_ok());
}

#[test]
fn test_certify_asset_full_mode_returns_error() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config = AssetCertificationConfig {
        mode: CertificationMode::authenticated(),
        ..Default::default()
    };
    let result = router.certify_asset("/api/user", b"{}".to_vec(), config);
    assert!(matches!(result, Err(AssetRouterError::FullModeRequiresRequest)));
}

#[test]
fn test_alias_resolution() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config = AssetCertificationConfig {
        aliases: vec!["/index".to_string(), "/home".to_string()],
        ..Default::default()
    };
    router.certify_asset("/index.html", b"<html>".to_vec(), config).unwrap();
    
    // Canonical path works
    assert!(router.contains_asset("/index.html"));
    // Aliases resolve to canonical
    assert!(router.contains_asset("/index"));
    assert!(router.contains_asset("/home"));
    // get_asset returns same content for alias
    let canonical = router.get_asset("/index.html").unwrap();
    let via_alias = router.get_asset("/index").unwrap();
    assert_eq!(canonical.content, via_alias.content);
}

#[test]
fn test_fallback_longest_prefix_wins() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    // Register root fallback
    let config_root = AssetCertificationConfig {
        fallback_for: Some("/".to_string()),
        ..Default::default()
    };
    router.certify_asset("/index.html", b"root".to_vec(), config_root).unwrap();
    
    // Register /api/ fallback
    let config_api = AssetCertificationConfig {
        fallback_for: Some("/api/".to_string()),
        ..Default::default()
    };
    router.certify_asset("/api/404.json", b"api-404".to_vec(), config_api).unwrap();
    
    // /api/unknown should match /api/ fallback (longer prefix), not /
    // (Verified via serve_asset with a mock request for /api/unknown)
}

#[test]
fn test_delete_asset_removes_from_tree_and_aliases() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config = AssetCertificationConfig {
        aliases: vec!["/home".to_string()],
        ..Default::default()
    };
    router.certify_asset("/index.html", b"<html>".to_vec(), config).unwrap();
    assert!(router.contains_asset("/index.html"));
    assert!(router.contains_asset("/home"));
    
    router.delete_asset("/index.html");
    assert!(!router.contains_asset("/index.html"));
    assert!(!router.contains_asset("/home")); // alias also removed
}

#[test]
fn test_delete_asset_via_alias() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config = AssetCertificationConfig {
        aliases: vec!["/home".to_string()],
        ..Default::default()
    };
    router.certify_asset("/index.html", b"<html>".to_vec(), config).unwrap();
    
    // Deleting via alias should also work
    router.delete_asset("/home");
    assert!(!router.contains_asset("/index.html"));
    assert!(!router.contains_asset("/home"));
}

#[test]
fn test_encoding_negotiation() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config = AssetCertificationConfig {
        encodings: vec![
            (AssetEncoding::Gzip, b"gzipped".to_vec()),
            (AssetEncoding::Brotli, b"brotlied".to_vec()),
        ],
        ..Default::default()
    };
    router.certify_asset("/app.js", b"raw".to_vec(), config).unwrap();
    
    // Brotli preferred over Gzip
    // Gzip used when Brotli not accepted
    // Identity fallback when no encoding accepted
    // (Verified via serve_asset with different Accept-Encoding headers)
}

#[test]
fn test_is_dynamic_and_is_expired() {
    let asset_static = CertifiedAsset { ttl: None, certified_at: 0, /* ... */ };
    assert!(!asset_static.is_dynamic());
    assert!(!asset_static.is_expired(u64::MAX));
    
    let one_hour = Duration::from_secs(3600);
    let asset_dynamic = CertifiedAsset {
        ttl: Some(one_hour),
        certified_at: 1_000_000_000_000_000_000,
        /* ... */
    };
    assert!(asset_dynamic.is_dynamic());
    assert!(!asset_dynamic.is_expired(asset_dynamic.certified_at + 1));
    assert!(asset_dynamic.is_expired(asset_dynamic.certified_at + one_hour.as_nanos() as u64));
}

#[test]
fn test_root_hash_changes_on_certify_and_delete() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let hash_empty = router.root_hash();
    
    router.certify_asset("/a", b"a".to_vec(), Default::default()).unwrap();
    let hash_one = router.root_hash();
    assert_ne!(hash_empty, hash_one);
    
    router.certify_asset("/b", b"b".to_vec(), Default::default()).unwrap();
    let hash_two = router.root_hash();
    assert_ne!(hash_one, hash_two);
    
    router.delete_asset("/a");
    let hash_after_delete = router.root_hash();
    assert_ne!(hash_two, hash_after_delete);
}

#[test]
fn test_recertify_same_path_replaces_old() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    router.certify_asset("/page", b"v1".to_vec(), Default::default()).unwrap();
    let hash_v1 = router.root_hash();
    
    // Re-certify with different content
    router.delete_asset("/page");
    router.certify_asset("/page", b"v2".to_vec(), Default::default()).unwrap();
    let hash_v2 = router.root_hash();
    
    assert_ne!(hash_v1, hash_v2);
    assert_eq!(router.get_asset("/page").unwrap().content, b"v2");
}
```

#### 4. Edge Case Tests

```rust
#[test]
fn test_special_characters_in_header_names() {
    let config = FullConfig::builder()
        .with_request_headers(&["x-custom-header", "x-request-id", "x-123-numeric"])
        .build();
    assert_eq!(config.request_headers.len(), 3);
    assert!(config.request_headers.contains(&"x-custom-header".to_string()));
}

#[test]
fn test_certification_mode_switching() {
    // Certify with ResponseOnly, then delete and re-certify with Skip.
    // Verifies the tree is correctly updated and the old certification is gone.
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    
    let config_ro = AssetCertificationConfig {
        mode: CertificationMode::response_only(),
        ..Default::default()
    };
    router.certify_asset("/page", b"v1".to_vec(), config_ro).unwrap();
    let hash_ro = router.root_hash();
    
    // Switch to Skip
    router.delete_asset("/page");
    let config_skip = AssetCertificationConfig {
        mode: CertificationMode::skip(),
        ..Default::default()
    };
    router.certify_asset("/page", b"v1".to_vec(), config_skip).unwrap();
    let hash_skip = router.root_hash();
    
    // Root hash should differ — different certification in tree
    assert_ne!(hash_ro, hash_skip);
    
    // Verify the asset now has Skip mode
    let asset = router.get_asset("/page").unwrap();
    assert!(matches!(asset.certification_mode, CertificationMode::Skip));
}

#[test]
fn test_large_query_param_values() {
    // Query params with special characters, spaces, unicode
    let config = FullConfig::builder()
        .with_query_params(&["q", "filter", "sort"])
        .build();
    // Builder should not panic with any string values
    assert_eq!(config.query_params.len(), 3);
}

#[test]
fn test_get_asset_nonexistent_returns_none() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let router = AssetRouter::with_tree(tree);
    assert!(router.get_asset("/nonexistent").is_none());
}

#[test]
fn test_delete_nonexistent_is_noop() {
    let tree = Rc::new(RefCell::new(HttpCertificationTree::default()));
    let mut router = AssetRouter::with_tree(tree);
    let hash_before = router.root_hash();
    router.delete_asset("/nonexistent"); // Should not panic
    assert_eq!(router.root_hash(), hash_before);
}
```

#### 5. Dynamic Route Integration Tests (PocketIC)

```rust
#[test]
fn test_dynamic_route_skip_serves_from_query_without_upgrade() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    deploy_with_skip_dynamic_route(&pic, canister);
    
    // First request triggers update to generate + cache
    let response = update(&pic, canister, "/api/health");
    assert_eq!(response.status, 200);
    
    // Subsequent query should serve cached response without ic-certificate
    let response = query(&pic, canister, "/api/health");
    assert_eq!(response.status, 200);
    assert!(!response.headers.contains_key("ic-certificate"));
}

#[test]
fn test_dynamic_route_authenticated_full_cycle() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    deploy_with_authenticated_route(&pic, canister);
    
    // First query should return upgrade response (not yet cached)
    let response = query(&pic, canister, "/api/profile");
    // ... triggers upgrade to update call ...
    
    // Update call with auth header certifies using Full mode
    let response = update_with_header(
        &pic, canister, "/api/profile",
        vec![("Authorization", "Bearer alice")]
    );
    assert_eq!(response.status, 200);
    
    // Subsequent query with same auth header serves certified response
    let response = query_with_header(
        &pic, canister, "/api/profile",
        vec![("Authorization", "Bearer alice")]
    );
    assert!(response.headers.contains_key("ic-certificate"));
    
    // Verify certificate is valid
    let result = verify_response_with_headers(
        &pic, canister, &response,
        vec![("Authorization", "Bearer alice")]
    );
    assert!(result.is_valid);
}

#[test]
fn test_invalidation_with_unified_router() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    deploy_with_mixed_modes(&pic, canister);
    
    // Verify dynamic asset exists and is served
    let response = query(&pic, canister, "/api/data");
    assert_eq!(response.status, 200);
    
    // Invalidate the dynamic path
    call_invalidate_path(&pic, canister, "/api/data");
    
    // Next query should trigger re-generation (upgrade)
    // Static assets should be unaffected
    let static_response = query(&pic, canister, "/static/style.css");
    assert_eq!(static_response.status, 200);
    assert!(static_response.headers.contains_key("ic-certificate"));
}

#[test]
fn test_invalidate_prefix_with_unified_router() {
    let pic = PocketIc::new();
    let canister = setup_canister(&pic);
    deploy_with_multiple_dynamic_routes(&pic, canister);
    
    // Invalidate all /api/ paths
    call_invalidate_prefix(&pic, canister, "/api/");
    
    // All /api/ dynamic assets should be gone
    // Non-/api/ dynamic assets should remain
    // Static assets unaffected
}
```

### Test Infrastructure

#### Helper Functions

```rust
// tests/common/mod.rs

pub fn setup_canister(pic: &PocketIc) -> Principal {
    // Create and install canister
}

pub fn deploy_with_skip_route(pic: &PocketIc, canister: Principal) {
    // Deploy canister with skip certification config
}

pub fn deploy_with_static_assets(pic: &PocketIc, canister: Principal) {
    // Deploy with response-only certification
}

pub fn deploy_with_auth_api(pic: &PocketIc, canister: Principal) {
    // Deploy with full certification requiring auth
}

pub fn query(
    pic: &PocketIc, 
    canister: Principal, 
    path: &str
) -> HttpResponse {
    // Make query call
}

pub fn query_with_header(
    pic: &PocketIc,
    canister: Principal,
    path: &str,
    headers: Vec<(&str, &str)>
) -> HttpResponse {
    // Make query with headers
}

pub fn verify_response(
    pic: &PocketIc,
    canister: Principal,
    response: &HttpResponse
) -> VerificationResult {
    // Use ic-certificate-verification or similar
}
```

#### Test Canister

Create a test canister that exposes all certification modes:

```rust
// tests/fixtures/certification_test_canister/src/lib.rs

#[init]
fn init() {
    // Certify assets with different modes
    certify_assets_with_mode(
        &include_dir!("assets/public"),
        CertificationMode::skip()
    );
    
    certify_assets(
        &include_dir!("assets/static"),
    );  // Uses response_only() by default
    
    // Dynamic routes configured via RouteConfig
}

// Routes with different certification configs
```

### Verification Testing

Use the `ic-certificate-verification` crate to verify responses:

```rust
use ic_certificate_verification::verify_certificate;

pub fn verify_response(
    response: &HttpResponse,
    request: &HttpRequest,
    canister_id: &Principal,
) -> Result<(), VerificationError> {
    // Extract certificate from response headers
    let certificate_header = response
        .headers()
        .iter()
        .find(|(k, _)| k == "ic-certificate")
        .map(|(_, v)| v)
        .ok_or(VerificationError::MissingCertificate)?;
    
    // Parse and verify
    verify_certificate(
        certificate_header,
        &response,
        request,
        canister_id,
        // ... other params
    )
}
```

## Files to Create

- `tests/certification_modes.rs` — Main certification mode tests
- `tests/common/mod.rs` — Shared test utilities
- `tests/fixtures/certification_test_canister/` — Test canister

## Files to Modify

- `Cargo.toml` — Add test dependencies (pocket-ic, ic-certificate-verification)
- `.github/workflows/test.yml` — Add certification tests to CI

## Acceptance Criteria

### Unit tests (no IC runtime)
- [ ] CEL expression generation for all three modes (Skip, ResponseOnly, Full)
- [ ] CEL for ResponseOnly with explicit headers and with exclusions
- [ ] CEL for Full with headers, query params, and empty config
- [ ] `CertificationMode::default()` returns `ResponseOnly`
- [ ] `skip()`, `response_only()`, `authenticated()` constructors produce correct variants
- [ ] `authenticated()` preset has `authorization` in request_headers and `content-type` in response
- [ ] `FullConfigBuilder` with all options, partial options, and no options
- [ ] Header name normalization (request and response headers lowercased)
- [ ] Query params NOT lowercased (case-sensitive)
- [ ] `certify_asset` with Full mode returns `FullModeRequiresRequest` error
- [ ] Alias resolution (`get_asset`, `contains_asset` via alias path)
- [ ] `delete_asset` removes canonical, aliases, and fallback entries
- [ ] `delete_asset` via alias path resolves and removes canonical
- [ ] `delete_asset` on nonexistent path is a no-op
- [ ] Root hash changes after certify and delete
- [ ] Re-certification of same path replaces old content and certification
- [ ] Certification mode switching (delete + re-certify with different mode)
- [ ] Encoding negotiation (Brotli preferred, Gzip fallback, Identity default)
- [ ] `is_dynamic()` and `is_expired()` on `CertifiedAsset`
- [ ] Fallback registration sorted by scope length (longest-first)

### Integration tests (PocketIC)
- [ ] Skip mode: response served without `ic-certificate` header
- [ ] ResponseOnly mode: certificate present and verifies
- [ ] Full (authenticated): certificate valid with correct Authorization header
- [ ] Full (authenticated): certificate invalid with different Authorization header
- [ ] Full (query params): certificate valid with matching params
- [ ] Full (query params): certificate invalid with different params
- [ ] Mixed modes in single canister: each route uses its configured mode
- [ ] Dynamic route with Skip mode: query serves without upgrade
- [ ] Dynamic route with authenticated mode: full update-then-query cycle
- [ ] Invalidation with unified router: `invalidate_path`, `invalidate_prefix`
- [ ] Static assets unaffected by dynamic invalidation

### Infrastructure
- [ ] Test helpers for common operations (setup, query, verify)
- [ ] Test canister fixture with all certification configurations
- [ ] CI runs certification tests on every PR
- [ ] Tests document expected behavior for each mode
