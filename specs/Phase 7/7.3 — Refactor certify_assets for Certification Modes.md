# 7.3 — Refactor certify_assets for Certification Modes

**Phase:** 7 — Configurable Certification Modes  
**Priority:** Critical  
**Status:** Not started

## Problem

The current `certify_all_assets(&dir)` function uses our new `AssetRouter` (from spec 7.2), but it doesn't expose the certification mode parameter. Users need a way to:

- Skip certification for certain asset groups (public health checks)
- Use full certification for assets that depend on request headers
- Configure which headers are included in the certification hash

The function name `certify_all_assets` is also misleading — it certifies assets in a directory, not all assets globally.

## Objective

1. Rename `certify_all_assets` to `certify_assets` to clarify it operates on a directory
2. Provide two variants: simple default and explicit mode selection
3. Support multiple calls with different certification modes for different asset groups
4. Default to `ResponseOnly` mode for backward-compatible simplicity

## Specification

### API Design: Two Functions

```rust
/// Certify all assets in the given directory with the default certification mode.
/// 
/// This is the simple, common-case API. It uses `ResponseOnly` certification,
/// which is appropriate for static assets where the response depends only on the path.
/// 
/// # Example
/// 
/// ```rust,ignore
/// // Simple: uses ResponseOnly certification (good for most static assets)
/// certify_assets(&include_dir!("assets"));
/// ```
pub fn certify_assets(asset_dir: &Dir<'static>) {
    certify_assets_with_mode(asset_dir, CertificationMode::response_only())
}

/// Certify all assets in the given directory with the specified certification mode.
/// 
/// This is the advanced API for when you need control over certification granularity.
/// Call this multiple times with different directories and modes to set up 
/// asset certification with varying security levels.
/// 
/// # Example
/// 
/// ```rust,ignore
/// // Static assets: response-only certification (default)
/// certify_assets(&include_dir!("assets/static"));
/// 
/// // Public files: skip certification entirely
/// certify_assets_with_mode(
///     &include_dir!("assets/public"),
///     CertificationMode::skip()
/// );
/// 
/// // Custom configuration: explicit control
/// certify_assets_with_mode(
///     &include_dir!("assets/api-docs"),
///     CertificationMode::Full(
///         FullConfig::builder()
///             .with_request_headers(&["accept"])
///             .build()
///     )
/// );
/// ```
pub fn certify_assets_with_mode(
    asset_dir: &Dir<'static>,
    mode: CertificationMode,
) {
    // Implementation
}
```

### Implementation

```rust
pub fn certify_assets_with_mode(asset_dir: &Dir<'static>, mode: CertificationMode) {
    ASSET_ROUTER.with_borrow_mut(|router| {
        certify_dir_recursive(router, asset_dir, &mode);
        
        // Update certified data after all assets are certified
        certified_data_set(&router.root_hash());
    });
}

/// Recursively certify all files in the directory and its subdirectories.
fn certify_dir_recursive(
    router: &mut AssetRouter,
    dir: &Dir<'static>,
    mode: &CertificationMode,
) {
    for file in dir.files() {
        let raw_path = file.path().to_string_lossy().to_string();
        let path = if raw_path.starts_with('/') {
            raw_path
        } else {
            format!("/{raw_path}")
        };
        let content = file.contents().to_vec();
        
        let config = AssetCertificationConfig {
            mode: mode.clone(),
            content_type: Some(guess_mime_type(&path)),
            headers: get_default_headers(),
            encodings: prepare_encodings(&content),
            certified_at: ic_cdk::api::time(),
            ttl: None, // Static assets don't expire
            ..Default::default()
        };
        
        router.certify_asset(&path, content, config)
            .expect("Failed to certify asset");
    }
    
    // Recurse into subdirectories
    for subdir in dir.dirs() {
        certify_dir_recursive(router, subdir, mode);
    }
}
```

### Key Design Decisions

**1. Separate functions over builder pattern**

Two functions are simpler than a builder:
```rust
// Clear and explicit:
certify_assets(&dir);  // Default
certify_assets_with_mode(&dir, mode);  // Custom

// vs builder which is more verbose for simple case:
certify_assets(&dir).certify();  // Need .certify() call
certify_assets(&dir).with_mode(mode).certify();
```

**2. Default is ResponseOnly, not Skip**

- **ResponseOnly**: Good security default, compatible with query calls
- **Skip**: Fastest but unverified — should be explicit opt-in

**3. Multiple calls accumulate**

```rust
// Certify different directories with different modes
fn init() {
    // Static assets: response-only (default)
    certify_assets(&include_dir!("assets/static"));
    
    // Public files: skip certification entirely
    certify_assets_with_mode(
        &include_dir!("assets/public"),
        CertificationMode::skip()
    );
}
```

## Files to Modify

- `src/assets.rs` — Implement `certify_assets` and `certify_assets_with_mode`
- `src/lib.rs` — Update exports

## Acceptance Criteria

- [ ] `certify_assets(&dir)` function exists and uses `ResponseOnly` mode
- [ ] `certify_assets_with_mode(&dir, mode)` function exists
- [ ] Both functions work with the unified `AssetRouter` from spec 7.2
- [ ] Multiple calls accumulate assets with different modes
- [ ] Default use case (`certify_assets(&dir)`) is one line
- [ ] Documentation shows simple case first, advanced case second
- [ ] All existing examples work with simple `certify_assets(&dir)` call
