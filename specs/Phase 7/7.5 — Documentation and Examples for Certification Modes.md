# 7.5 — Documentation and Examples for Certification Modes

**Phase:** 7 — Configurable Certification Modes  
**Priority:** Medium  
**Status:** Not started

## Problem

HTTP certification is complex and the trade-offs between different certification modes are subtle. Users need clear guidance on:

- When the default ResponseOnly mode is sufficient (90% of cases)
- When to skip certification entirely (public health checks, etc.)
- When to use Full certification (authenticated APIs)
- How to configure custom certification for special cases
- Performance and security trade-offs

Currently there is no documentation or examples demonstrating these features.

## Objective

Create comprehensive documentation and examples that demonstrate:
1. The default ResponseOnly mode (works for 90% of use cases)
2. When and how to deviate from the default (Skip and Full modes)
3. Common use cases (default static assets, authenticated APIs, public endpoints)
4. Performance and security trade-offs
5. When to use the built-in presets vs explicit configuration

## Specification

### Documentation to Create

#### 1. Guide: "Configuring HTTP Certification"

Location: `docs/certification.md` or `README.md` section

Sections:
- Overview of certification modes
- Decision tree for choosing a mode
- Simple examples (default, skip, authenticated)
- Advanced examples (custom configuration)
- Header selection best practices
- Query parameter certification
- Performance considerations

#### 2. API Documentation

All new types must have comprehensive rustdoc:
- `CertificationMode` — when to use each variant
- `ResponseOnlyConfig` — header include/exclude behavior
- `FullConfig` — request vs response certification (note: method and body are always certified)
- `authenticated()` preset — when to use it

### Examples to Create

#### Example 1: `certification-modes`

Demonstrates the three common certification scenarios:

```
examples/certification-modes/
├── Cargo.toml
├── dfx.json
├── src/
│   └── lib.rs
└── assets/
    ├── public/          # Skip certification
    │   └── health.html
    ├── static/          # Response-only (default)
    │   ├── style.css
    │   └── app.js
    └── api/             # Response-only (API docs)
        └── schema.json
```

Route structure:
```
src/routes/
├── index.rs                    # Response-only (default, no attribute)
├── public/
│   └── health.rs               # Skip certification
├── api/
│   └── user.rs                 # Authenticated (Authorization header)
└── content/
    └── articles.rs             # Custom (pagination query params)
```

Example code:

```rust
// src/routes/index.rs
// Default: no attribute needed, uses ResponseOnly
pub fn get(ctx: RouteContext<()>) -> HttpResponse<'static> {
    HttpResponse::builder()
        .with_body(b"Welcome!")
        .build()
}
```

```rust
// src/routes/public/health.rs
use ic_asset_router::route;

/// Health check endpoint — no certification needed for public status
#[route(certification = "skip")]
pub fn get(ctx: RouteContext<()>) -> HttpResponse<'static> {
    HttpResponse::builder()
        .with_status_code(200)
        .with_body(b"{\"status\":\"ok\"}")
        .build()
}
```

```rust
// src/routes/api/user.rs
use ic_asset_router::route;

/// Authenticated endpoint — different users get different certified responses
#[route(certification = "authenticated")]
pub fn get(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // The Authorization header is automatically included in certification
    // User A cannot receive User B's cached response
    let auth_header = ctx.headers.iter()
        .find(|(k, _)| k.eq_ignore_ascii_case("authorization"));
    
    // ... fetch user profile based on auth token
    HttpResponse::builder()
        .with_body(b"{\"name\":\"Alice\"}")
        .build()
}
```

```rust
// src/routes/content/articles.rs
use ic_asset_router::route;

/// Paginated listing — each page is a separate certified response
#[route(certification = custom(
    query_params = ["page", "limit"]
))]
pub fn get(ctx: RouteContext<()>) -> HttpResponse<'static> {
    let page = ctx.query.get("page").unwrap_or("1");
    let limit = ctx.query.get("limit").unwrap_or("10");
    
    // Page 2 and Page 3 have different certificates
    // A malicious replica cannot serve Page 1 when Page 2 is requested
    HttpResponse::builder()
        .with_body(format!("Articles page {}", page))
        .build()
}
```

#### Example 2: `api-authentication`

Focused example demonstrating why authentication requires full certification:

```rust
// src/routes/
// ├── profile.rs      # Uses "authenticated" preset
// └── public.rs       # Uses no attribute (default ResponseOnly)

// src/routes/profile.rs
#[route(certification = "authenticated")]
pub fn get(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // With #[route(certification = "authenticated")]:
    // - Alice requests /profile with Authorization: Bearer alice-token
    // - Response is certified with her token
    // - Malicious replica cannot give Alice Bob's profile
    //   because the certificate would not match
    
    HttpResponse::builder()
        .with_body(b"{\"name\":\"Alice\",\"email\":\"alice@example.com\"}")
        .build()
}

// src/routes/public.rs
// No attribute — uses ResponseOnly (everyone gets same response)
pub fn about(ctx: RouteContext<()>) -> HttpResponse<'static> {
    HttpResponse::builder()
        .with_body(b"About this service...")
        .build()
}
```

### Decision Tree for Users

```markdown
## Choosing a Certification Mode

### Start Simple: Response-Only (Default)
**This is what you want 90% of the time.**

**Use when:**
- Response depends only on the URL path
- Same URL always returns the same content (for a given state)
- Request headers and query params don't affect response

**How:**
```rust
// No attribute needed — just write your handler
pub fn get(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // Automatically uses ResponseOnly certification
}
```

**Example:** Static pages, blog posts by ID, about pages, documentation

---

### Skip Certification: When You Don't Need It
**Use when:**
- Response is public and tampering has no security impact
- Maximum performance is required
- Response is non-deterministic (timestamps, random data)

**How:**
```rust
#[route(certification = "skip")]
pub fn health(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // No certification overhead
}
```

**Example:** Health checks, public status pages, `/ping` endpoints

**Security note:** Malicious replica can return any data. Only use for data
that is publicly verifiable or has no security value.

---

### Authenticated: When Identity Affects Response
**Use when:**
- Response depends on who is making the request (Authorization header)
- Different users must receive different certified responses

**How:**
```rust
#[route(certification = "authenticated")]
pub fn get_user(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // Authorization header is automatically included in certification
    // User A cannot receive User B's cached response
}
```

**Example:** User profiles, personal dashboards, account settings

This is the `"authenticated"` preset — a preconfigured Full certification mode
that includes the `Authorization` request header and `Content-Type` response header.

---

### Custom: When Other Request Details Affect Response
**Use when:**
- Content negotiation (different formats based on Accept header)
- Pagination (different pages must be separately certified)
- API versioning (X-API-Version header affects response)
- Any case where you need Full certification with specific headers/params

**How:**
```rust
#[route(certification = custom(
    request_headers = ["accept"],  // Content negotiation
    query_params = ["page"]        // Pagination
))]
pub fn list(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // Explicit Full configuration — you specify exactly what to certify
}
```

**Example:** APIs supporting JSON/XML, paginated search results, versioned APIs
```

### Header Selection Guide

```markdown
## Which Headers to Certify?

Only certify headers that **affect the response content**.

### Common Request Headers

| Header | Certify? | When? |
|--------|----------|-------|
| `Authorization` | **Yes** | Always for authenticated endpoints (who you are affects what you see) |
| `Accept` | Sometimes | If you return different formats (JSON vs HTML) |
| `Accept-Encoding` | Rarely | Usually handled by automatic compression |
| `Accept-Language` | Sometimes | If you localize content per language |
| `User-Agent` | **No** | Never — too varied, causes cache fragmentation |
| `Cookie` | **No** | Never — too large, privacy issues |

### Golden Rule
**If changing the header value would change the response body, certify it.**

Example:
- `Authorization: Bearer alice-token` → Alice's profile ✅ **Certify**
- `Accept: application/json` → JSON response ✅ **Certify** (if you support multiple formats)
- `User-Agent: Mozilla/5.0` → Same HTML response ❌ **Don't certify**
```

### Performance Comparison

```markdown
## Performance by Certification Mode

| Mode | Cycles | Witness Size | When to Use |
|------|--------|--------------|-------------|
| **Skip** | ~0 | 0 bytes | Public health checks only |
| **Response-only** | ~1000 | ~200 bytes | **Default for 90% of routes** |
| **Full (auth)** | ~2000 | ~300 bytes | Authenticated APIs |
| **Full (custom)** | ~2000-5000 | ~300-500 bytes | Special cases |

**Key insight:** Response-only is fast and secure for most use cases.
Only use Full certification when you need to prevent cross-user response mixing.
```

### Common Mistakes to Avoid

```markdown
## Certification Anti-Patterns

### ❌ Over-Certifying
```rust
// WRONG: Certifying headers that don't affect response
#[route(certification = custom(
    request_headers = ["authorization", "user-agent", "accept-language"]
))]
```
**Problem:** User-Agent varies wildly (every browser version is different).
This creates a separate certificate for every visitor, defeating caching.

**Fix:** Only certify headers that affect response content.

### ❌ Under-Certifying
```rust
// WRONG: Response-only for authenticated endpoint
// No attribute = ResponseOnly by default
pub fn get_profile(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // Alice could receive Bob's cached profile!
}
```
**Problem:** Without Authorization header in certification, the replica
can serve any cached profile to any user.

**Fix:** Use `#[route(certification = "authenticated")]` for authenticated endpoints.

### ❌ Certifying Dynamic Data
```rust
// WRONG: Timestamp in response makes certification useless
#[route(certification = "response_only")]
pub fn get_time(ctx: RouteContext<()>) -> HttpResponse<'static> {
    HttpResponse::builder()
        .with_body(format!("Time: {}", ic_cdk::api::time()))  // Changes every call!
        .build()
}
```
**Problem:** Response changes every millisecond, certificate is immediately stale.

**Fix:** Use `#[route(certification = "skip")]` for truly dynamic data,
or cache for a specific duration with TTL.
```

## Files to Create

- `examples/certification-modes/` — Comprehensive example
- `examples/api-authentication/` — Focused auth example
- `docs/certification.md` — Detailed guide

## Files to Modify

- `README.md` — Add certification section with decision tree
- `src/lib.rs` — Add module-level documentation

## Acceptance Criteria

- [ ] README has section explaining certification modes with decision tree
- [ ] Documentation shows simple default case first (no attribute = ResponseOnly)
- [ ] `certification-modes` example demonstrates Skip, ResponseOnly (default), "authenticated", and custom
- [ ] `api-authentication` example shows why Authorization header certification matters
- [ ] Examples use `#[route]` attribute (not CONFIG constants)
- [ ] Examples use preset strings consistent with 7.4: `"skip"`, `"response_only"`, `"authenticated"`, `custom(...)`
- [ ] Documentation explains performance implications of each mode
- [ ] Documentation explains security implications of skipping certification
- [ ] Header selection guide follows "certify only if it affects response" rule
- [ ] Anti-patterns section explains common mistakes
- [ ] All examples can be run with `dfx deploy` and tested with curl
