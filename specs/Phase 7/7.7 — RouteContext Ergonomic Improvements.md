# 7.7 — RouteContext Ergonomic Improvements

**Status:** Draft
**Depends on:** None (additive methods on existing `RouteContext`)

---

## Motivation

Several patterns repeat across route handlers and internal code:

| Pattern | Occurrences | Boilerplate |
|---------|-------------|-------------|
| Header lookup | 5+ | `ctx.headers.iter().find(\|(k, _)\| k.eq_ignore_ascii_case("...")).map(\|(_, v)\| v.as_str())` |
| Body as string | 3+ | `String::from_utf8_lossy(&ctx.body)` |
| JSON deserialization | 2+ | `serde_json::from_str(&String::from_utf8_lossy(&ctx.body))` |
| Form body parsing | 1+ | `parse_form_body(&ctx.body)` (requires import) |

These patterns are verbose, error-prone (case-sensitivity bugs in header names), and distract from handler logic. Adding convenience methods to `RouteContext` reduces noise and encourages correct usage.

---

## 7.7.1 — `ctx.header(name)`: Case-Insensitive Header Lookup

### API

```rust
impl<P, S> RouteContext<P, S> {
    /// Returns the value of the first header matching `name` (case-insensitive).
    ///
    /// Returns `None` if no header with that name exists.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// let auth = ctx.header("authorization"); // Option<&str>
    /// let ct = ctx.header("Content-Type");    // case-insensitive
    /// ```
    pub fn header(&self, name: &str) -> Option<&str> {
        self.headers
            .iter()
            .find(|(k, _)| k.eq_ignore_ascii_case(name))
            .map(|(_, v)| v.as_str())
    }
}
```

### Design decisions

- **Returns `Option<&str>`**, not `Option<&String>` — callers rarely need the owned `String`.
- **First match wins** — HTTP allows duplicate headers, but for the common case (Authorization, Content-Type, Accept) there is only one. Handlers that need all values for a given name can still use `ctx.headers` directly.
- **No allocation** — borrows from the existing `Vec<HeaderField>`.

### Acceptance criteria

1. `ctx.header("authorization")` returns `Some("Bearer token")` when the header `("Authorization", "Bearer token")` is present.
2. `ctx.header("Authorization")` returns the same result (case-insensitive match).
3. `ctx.header("x-missing")` returns `None` when no such header exists.
4. Works on any `RouteContext<P, S>` regardless of `P` and `S` type parameters.

---

## 7.7.2 — `ctx.body_to_str()`: Body as String Slice

### API

```rust
impl<P, S> RouteContext<P, S> {
    /// Returns the request body as a UTF-8 string.
    ///
    /// Returns `Err` if the body is not valid UTF-8. For lossy conversion,
    /// use `String::from_utf8_lossy(&ctx.body)` directly.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// match ctx.body_to_str() {
    ///     Ok(text) => { /* use text */ }
    ///     Err(_) => { /* return 400 */ }
    /// }
    /// ```
    pub fn body_to_str(&self) -> Result<&str, std::str::Utf8Error> {
        std::str::from_utf8(&self.body)
    }
}
```

### Design decisions

- **Returns `Result`, not lossy** — lossy conversion hides encoding errors silently, which is rarely what API handlers want. Handlers that want lossy conversion can still call `String::from_utf8_lossy(&ctx.body)`.
- **Zero-copy** — returns a `&str` that borrows from `self.body`.
- **Idiomatic name** — `body_to_str` follows the `CStr::to_str()` convention where `to_*` signals a fallible conversion.

### Acceptance criteria

1. `ctx.body_to_str()` returns `Ok("hello")` when `ctx.body` is `b"hello"`.
2. `ctx.body_to_str()` returns `Err(Utf8Error)` when `ctx.body` contains invalid UTF-8 bytes.
3. The returned `&str` borrows from `ctx.body` (no allocation).

---

## 7.7.3 — `ctx.json::<T>()`: JSON Body Deserialization

### API

```rust
impl<P, S> RouteContext<P, S> {
    /// Deserializes the request body as JSON into type `T`.
    ///
    /// Returns `Err` if the body is not valid UTF-8 or if JSON
    /// deserialization fails.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// #[derive(serde::Deserialize)]
    /// struct CreateItem { name: String }
    ///
    /// pub fn post(ctx: RouteContext<()>) -> HttpResponse<'static> {
    ///     let input: CreateItem = match ctx.json() {
    ///         Ok(v) => v,
    ///         Err(_) => return bad_request("invalid JSON body"),
    ///     };
    ///     // ...
    /// }
    /// ```
    pub fn json<T: serde::de::DeserializeOwned>(&self) -> Result<T, JsonBodyError> {
        let text = std::str::from_utf8(&self.body)
            .map_err(JsonBodyError::Utf8)?;
        serde_json::from_str(text)
            .map_err(JsonBodyError::Json)
    }
}
```

### Error type

```rust
/// Error returned by `RouteContext::json()`.
#[derive(Debug)]
pub enum JsonBodyError {
    /// The body bytes are not valid UTF-8.
    Utf8(std::str::Utf8Error),
    /// JSON deserialization failed.
    Json(serde_json::Error),
}

impl std::fmt::Display for JsonBodyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Utf8(e) => write!(f, "body is not valid UTF-8: {e}"),
            Self::Json(e) => write!(f, "JSON deserialization failed: {e}"),
        }
    }
}

impl std::error::Error for JsonBodyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Utf8(e) => Some(e),
            Self::Json(e) => Some(e),
        }
    }
}
```

### Design decisions

- **`serde_json` added as a direct dependency** — it is currently only used by example canisters, but JSON is the dominant format for IC canister APIs. The dependency is lightweight (~30KB compiled) and `serde` is already a direct dependency, so `serde_json` adds only the format layer. No feature gating.
- **Two-step parsing** — validates UTF-8 first, then deserializes. This is more explicit than `serde_json::from_slice` which also handles UTF-8 internally but gives less specific errors.
- **`JsonBodyError` is its own enum** — rather than a stringly-typed error, callers can match on the variant to distinguish "not UTF-8" from "valid UTF-8 but bad JSON".

### Cargo.toml change

```toml
[dependencies]
serde_json = "1.0"
```

### Acceptance criteria

1. `ctx.json::<CreateItem>()` returns `Ok(CreateItem { name: "test" })` when `ctx.body` is `b'{"name":"test"}'`.
2. `ctx.json::<CreateItem>()` returns `Err(JsonBodyError::Json(_))` when body is `b'{invalid}'`.
3. `ctx.json::<CreateItem>()` returns `Err(JsonBodyError::Utf8(_))` when body contains invalid UTF-8.
4. `JsonBodyError` implements `Display` and `Error`.

---

## 7.7.4 — `ctx.form_data()` and `ctx.form::<T>()`: Form Body Helpers

### API — untyped

```rust
impl<P, S> RouteContext<P, S> {
    /// Parses the request body as `application/x-www-form-urlencoded` key-value pairs.
    ///
    /// Convenience wrapper around `parse_form_body(&self.body)`.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// let fields = ctx.form_data();
    /// let author = fields.get("author").cloned().unwrap_or_default();
    /// ```
    pub fn form_data(&self) -> HashMap<String, String> {
        parse_form_body(&self.body)
    }
}
```

### API — typed

```rust
impl<P, S> RouteContext<P, S> {
    /// Deserializes the request body as `application/x-www-form-urlencoded` into type `T`.
    ///
    /// Returns `Err` if the body is not valid UTF-8 or if deserialization fails.
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// #[derive(serde::Deserialize)]
    /// struct CommentForm { author: String, body: String }
    ///
    /// pub fn post(ctx: RouteContext<Params>) -> HttpResponse<'static> {
    ///     let form: CommentForm = match ctx.form() {
    ///         Ok(v) => v,
    ///         Err(_) => return bad_request("invalid form data"),
    ///     };
    ///     // ...
    /// }
    /// ```
    pub fn form<T: serde::de::DeserializeOwned>(&self) -> Result<T, FormBodyError> {
        let text = std::str::from_utf8(&self.body)
            .map_err(FormBodyError::Utf8)?;
        serde_urlencoded::from_str(text)
            .map_err(FormBodyError::Deserialize)
    }
}
```

### Error type

```rust
/// Error returned by `RouteContext::form()`.
#[derive(Debug)]
pub enum FormBodyError {
    /// The body bytes are not valid UTF-8.
    Utf8(std::str::Utf8Error),
    /// Form deserialization failed.
    Deserialize(serde_urlencoded::de::Error),
}

impl std::fmt::Display for FormBodyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Utf8(e) => write!(f, "body is not valid UTF-8: {e}"),
            Self::Deserialize(e) => write!(f, "form deserialization failed: {e}"),
        }
    }
}

impl std::error::Error for FormBodyError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Utf8(e) => Some(e),
            Self::Deserialize(e) => Some(e),
        }
    }
}
```

### Design decisions

- **No new dependencies** — `serde_urlencoded` is already used for `SearchParams` deserialization.
- **`form_data()` is infallible** — matches existing `parse_form_body` behavior (lossy UTF-8, skips malformed pairs). The untyped helper is for quick one-off field access.
- **`form::<T>()` is strict** — mirrors the `json::<T>()` pattern. Returns `Result` so callers can handle malformed input explicitly.
- **Parallel structure with `json()`** — typed body deserialization is `ctx.json::<T>()` for JSON, `ctx.form::<T>()` for form-encoded. Consistent naming.

### Acceptance criteria

1. `ctx.form_data()` returns a `HashMap` with `{"author": "Alice", "body": "hello"}` when `ctx.body` is `b"author=Alice&body=hello"`.
2. `ctx.form_data()` returns an empty `HashMap` for an empty body.
3. `ctx.form::<CommentForm>()` returns `Ok(CommentForm { author: "Alice", body: "hello" })` for valid input.
4. `ctx.form::<CommentForm>()` returns `Err(FormBodyError::Deserialize(_))` when required fields are missing.
5. `ctx.form::<CommentForm>()` returns `Err(FormBodyError::Utf8(_))` when body contains invalid UTF-8.
6. `FormBodyError` implements `Display` and `Error`.

---

## 7.7.5 — Migrate All Examples, E2E Tests, and Internal Code

**Every** example canister, e2e test route handler, and internal call site that uses the verbose patterns must be migrated to the new convenience methods. The tables below list known occurrences at time of writing, but the implementor must do a full codebase search for the old patterns and migrate any additional hits.

### Header lookup migrations

| File | Before | After |
|------|--------|-------|
| `examples/api-authentication/src/routes/profile.rs:25-29` | `ctx.headers.iter().find(\|(k, _)\| k.eq_ignore_ascii_case("authorization")).map(\|(_, v)\| v.as_str())` | `ctx.header("authorization")` |
| `examples/certification-modes/src/routes/api/user.rs:19-24` | Same pattern | `ctx.header("authorization").unwrap_or("anonymous")` |
| `tests/e2e/test_canister/src/routes/auth_test.rs:13` | Same pattern | `ctx.header("authorization")` |

### Body string migrations

| File | Before | After |
|------|--------|-------|
| `examples/json-api/src/routes/items/index.rs:25` | `String::from_utf8_lossy(&ctx.body)` + `serde_json::from_str` | `ctx.json::<CreateItem>()` |
| `examples/json-api/src/routes/items/_itemId/index.rs:40` | Same pattern | `ctx.json::<CreateItem>()` |

### Form body migrations

| File | Before | After |
|------|--------|-------|
| `examples/htmx-app/src/routes/posts/_postId/comments.rs:33` | `parse_form_body(&ctx.body)` | `ctx.form_data()` |

### Deprecated API migrations

| File(s) | Before | After |
|---------|--------|-------|
| All examples and e2e tests calling `certify_all_assets` | `certify_all_assets(...)` | `certify_assets(...)` |

### Dependency version cleanup

| File | Before | After |
|------|--------|-------|
| `Cargo.toml` | `ic-http-certification = "3.0.3"` (resolves to 3.1.0) | `ic-http-certification = "3.1"` (match actual resolved version) |

### Internal code migrations

| File | Before | After |
|------|--------|-------|
| `src/lib.rs:244` | `ctx.headers.iter().find(\|(k, _)\| k.eq_ignore_ascii_case("content-type"))` | `ctx.header("content-type")` (or equivalent, depending on what surrounding code needs) |
| `src/asset_router.rs:723` | Same pattern for `accept-encoding` | Evaluate — this operates on raw `&[(String, String)]` from `HttpRequest`, not on `RouteContext`, so it may not apply. |

### Acceptance criteria

1. All example canisters compile and work identically after migration.
2. All e2e test route handlers compile and work identically after migration.
3. All existing tests (unit and e2e) pass without modification (behavior unchanged).
4. **Zero remaining verbose patterns in any route handler or test handler** — no `eq_ignore_ascii_case` header lookups, no `String::from_utf8_lossy(&ctx.body)` + `serde_json::from_str`, no `parse_form_body(&ctx.body)` imports — unless the code operates on raw `HttpRequest` (not `RouteContext`).
5. A grep for `eq_ignore_ascii_case` in `examples/` and `tests/e2e/` returns zero hits on `RouteContext`-based code.
6. Zero calls to deprecated `certify_all_assets` in examples or e2e tests — all migrated to `certify_assets`.
7. `ic-http-certification` version in `Cargo.toml` matches the actual resolved version.

---

## 7.7.6 — Unit Tests

New tests in `src/context.rs` (in the existing `#[cfg(test)] mod tests` block):

### `header` tests

- `header_case_insensitive` — `ctx.header("Authorization")` and `ctx.header("authorization")` both find `("authorization", "Bearer x")`.
- `header_missing` — `ctx.header("x-missing")` returns `None` on empty headers.
- `header_first_match_wins` — when two headers share the same name, the first value is returned.

### `body_to_str` tests

- `body_to_str_valid_utf8` — returns `Ok("hello")`.
- `body_to_str_invalid_utf8` — returns `Err(Utf8Error)`.
- `body_to_str_empty` — returns `Ok("")`.

### `json` tests

- `json_valid` — deserializes `{"name":"test"}` into a struct.
- `json_invalid_json` — returns `JsonBodyError::Json`.
- `json_invalid_utf8` — returns `JsonBodyError::Utf8`.
- `json_empty_body` — returns `JsonBodyError::Json` (empty string is not valid JSON).

### `form_data` tests

- `form_data_basic` — parses `b"name=Alice&age=30"` into `{"name": "Alice", "age": "30"}`.
- `form_data_empty` — returns empty `HashMap` for empty body.
- `form_data_url_encoded` — decodes `+` and `%XX` sequences.

### `form` tests

- `form_valid` — deserializes `b"author=Alice&body=hello"` into a struct.
- `form_missing_field` — returns `FormBodyError::Deserialize` when a required field is absent.
- `form_invalid_utf8` — returns `FormBodyError::Utf8`.
- `form_empty_body` — deserializes successfully if all fields are `Option`.

### Test helper

To reduce boilerplate in tests, add a helper to construct a `RouteContext<()>`:

```rust
#[cfg(test)]
fn test_ctx(headers: Vec<(String, String)>, body: Vec<u8>) -> RouteContext<()> {
    RouteContext {
        params: (),
        search: (),
        query: QueryParams::new(),
        method: Method::GET,
        headers,
        body,
        url: String::new(),
        wildcard: None,
    }
}
```

### Acceptance criteria

1. All new tests pass.
2. Existing tests in `context.rs` still pass.
3. `cargo test` succeeds with no regressions.

---

## 7.7.7 — Replace String-Based Source Scanning with `syn` Parsing in Build Script

### Motivation

The build script (`src/build.rs`) uses line-by-line string matching to detect `#[route(certification = ...)]` attributes and `pub struct SearchParams` declarations. This is fragile:

- **Multi-line attributes are missed.** `rustfmt` will split long `#[route(...)]` attributes across lines, and the current `starts_with("#[route(")` check only looks at single lines.
- **Comments and string literals can false-positive.** A comment containing `#[route(certification` would be detected as an attribute.
- **The `custom(...)` syntax with multiple fields is almost certain to be multi-line** in practice, making this a real correctness bug, not a theoretical concern.

`syn` is already a dependency of this project (via the `macros/` crate). Adding it as a `[build-dependencies]` entry lets the build script parse source files into a proper AST.

### Changes

#### `Cargo.toml`

Add `syn` as a build dependency:

```toml
[build-dependencies]
syn = { version = "2", features = ["full", "parsing"] }
```

#### `src/build.rs`

Replace `scan_certification_attribute()` with a `syn`-based implementation:

```rust
/// Scan a Rust source file for a `#[route(...)]` attribute containing
/// a `certification` key.
///
/// Parses the file with `syn` and walks top-level function items looking
/// for `#[route(...)]` attributes. Returns `true` if any such attribute
/// contains a `certification` key.
fn scan_certification_attribute(path: &Path) -> bool {
    let source = fs::read_to_string(path).unwrap_or_default();
    let file = match syn::parse_file(&source) {
        Ok(f) => f,
        Err(_) => return false, // unparseable file — treat as no attribute
    };
    for item in &file.items {
        if let syn::Item::Fn(func) = item {
            for attr in &func.attrs {
                if attr.path().is_ident("route") {
                    let tokens = attr.meta.require_list()
                        .map(|list| list.tokens.to_string())
                        .unwrap_or_default();
                    if tokens.contains("certification") {
                        return true;
                    }
                }
            }
        }
    }
    false
}
```

Similarly replace `has_search_params()`:

```rust
/// Scan a Rust source file for a `pub struct SearchParams` declaration.
fn has_search_params(path: &Path) -> bool {
    let source = fs::read_to_string(path).unwrap_or_default();
    let file = match syn::parse_file(&source) {
        Ok(f) => f,
        Err(_) => return false,
    };
    for item in &file.items {
        if let syn::Item::Struct(s) = item {
            if s.ident == "SearchParams"
                && s.vis == syn::Visibility::Public(syn::token::Pub::default())
            {
                return true;
            }
        }
    }
    false
}
```

### Design decisions

- **`syn::parse_file` is the right granularity** — we need to walk top-level items, not parse individual expressions. `parse_file` handles multi-line attributes, comments, and string literals correctly.
- **Fallback on parse error** — if the file doesn't parse (e.g. syntax error during development), return `false` rather than panicking. The proc macro will catch the error at compile time anyway.
- **Token stringification for `certification` check** — after extracting the attribute's token stream, a simple `contains("certification")` on the stringified tokens is sufficient. We don't need to deeply parse the attribute arguments here because the proc macro does the real parsing at compile time. The build script only needs a boolean "does this route have a certification config?"
- **Build time impact** — `syn` is already compiled for the `macros/` crate. Adding it to `[build-dependencies]` means it also compiles for the host target, adding ~2-3s to a clean build. Incremental builds are unaffected.

### Acceptance criteria

1. Multi-line `#[route(certification = ...)]` attributes are correctly detected.
2. `#[route(certification = ...)]` in comments or string literals is not detected.
3. `pub struct SearchParams` is correctly detected regardless of formatting.
4. All existing build script tests pass (update test expectations if needed).
5. All examples and e2e tests compile and pass.

---

## Out of Scope

- **Typed header methods** (e.g. `ctx.content_type()`) — premature specialization; the generic `ctx.header(name)` covers all cases.
- **Builder pattern for `RouteContext`** — only constructed internally by the framework, not by user code.
- **Changes to middleware signature** — middleware receives raw `HttpRequest`, not `RouteContext`, and is a separate concern.
