# 7.4 — Per-Route Certification Configuration

**Phase:** 7 — Configurable Certification Modes  
**Priority:** High  
**Status:** Not started

## Problem

Dynamic routes (defined in `src/routes/`) currently have no way to configure their certification mode. All dynamic routes use response-only certification via `certify_dynamic_response()`. This is insufficient for:

- API endpoints that depend on `Authorization` headers
- Routes that use content negotiation (`Accept` header)
- Public endpoints where certification overhead is unnecessary
- Routes with caching that depends on query parameters

## Objective

Provide per-route certification configuration via a `#[route]` attribute macro attached to handler functions. This approach:
- Doesn't require editing auto-generated mod.rs files
- Is ergonomic and discoverable in IDE
- Follows Rust ecosystem conventions (similar to Axum, Actix)

## Specification

### Approach: Attribute Macro on Handler

```rust
// src/routes/api/user.rs - user writes this file
use ic_asset_router::{route, RouteContext};

/// Public endpoint: skip certification entirely
#[route(certification = "skip")]
pub fn health(ctx: RouteContext<()>) -> HttpResponse<'static> {
    HttpResponse::builder()
        .with_status_code(200)
        .with_body(b"{\"status\":\"ok\"}")
        .build()
}

/// Authenticated endpoint: certify Authorization header
#[route(certification = "authenticated")]
pub fn get_user(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // ctx.headers contains "authorization" which is certified
    let auth = ctx.headers.iter()
        .find(|(k, _)| k.eq_ignore_ascii_case("authorization"));
    // ... fetch user based on auth token
}

/// Custom certification for content negotiation
#[route(certification = custom(
    request_headers = ["accept"]
))]
pub fn api_response(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // Different responses for Accept: application/json vs text/html
    // Both are certified separately
}

/// Custom certification for pagination
#[route(certification = custom(
    query_params = ["page", "limit"]
))]
pub fn list_items(ctx: RouteContext<()>) -> HttpResponse<'static> {
    let page = ctx.query.get("page").unwrap_or("1");
    // ... paginated response, certified with query params
}

/// Default: response-only certification (no attribute needed)
pub fn static_page(ctx: RouteContext<()>) -> HttpResponse<'static> {
    // Uses ResponseOnly mode automatically
}
```

### Attribute Syntax

```rust
#[route(
    certification = PRESET | custom(...)
)]
```

**Presets (string shortcuts):**
- `"skip"` — No certification (`CertificationMode::Skip`)
- `"response_only"` — Response-only certification (`CertificationMode::ResponseOnly`), same as default
- `"authenticated"` — Full certification with Authorization header (`CertificationMode::Full` with auth config)

**No attribute** — Uses `"response_only"` (the default for 90% of routes)

**Custom configuration:**
```rust
#[route(certification = custom(
    // Request headers to include in certification hash
    request_headers = ["authorization", "accept", "accept-encoding"],
    
    // Query parameters to include in certification hash
    query_params = ["page", "limit", "filter", "sort"],
    
    // Response headers to include in certification hash
    response_headers = ["content-type", "content-encoding", "etag"],
    
    // Cache TTL for this route (overrides global default)
    // Note: TTL is a caching concern, not a certification concern,
    // but is included here for ergonomic co-location with the handler.
    ttl = 300  // seconds
))]
```

### Implementation: Proc Macro

Create a proc-macro crate `ic-asset-router-macros`:

```rust
// src/macros/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn, AttributeArgs};

#[proc_macro_attribute]
pub fn route(args: TokenStream, input: TokenStream) -> TokenStream {
    let args = parse_macro_input!(args as AttributeArgs);
    let func = parse_macro_input!(input as ItemFn);
    
    // Parse certification configuration from args
    let cert_config = parse_certification_config(&args);
    
    // Generate a config function (not static — Vec is not const)
    let config_fn = quote! {
        #[doc(hidden)]
        pub fn __route_config() -> RouteConfig {
            #cert_config
        }
    };
    
    // Return the original function plus the config function
    let expanded = quote! {
        #func
        #config_fn
    };
    
    expanded.into()
}
```

**What the macro generates:**

For a handler like:
```rust
#[route(certification = "authenticated")]
pub fn get_user(ctx: RouteContext<()>) -> HttpResponse<'static> { ... }
```

The macro expands to:
```rust
pub fn get_user(ctx: RouteContext<()>) -> HttpResponse<'static> { ... }

/// Returns the route configuration for this handler.
/// Generated by the `#[route]` macro. Called by the route tree
/// at registration time.
///
/// Note: this is a function (not a `static`) because `RouteConfig`
/// contains `Vec` fields which cannot be used in const/static context.
#[doc(hidden)]
pub fn __route_config() -> RouteConfig {
    RouteConfig {
        certification: CertificationMode::authenticated(),
        ttl: None,
        headers: vec![],
    }
}
```

### Build Script Integration

The build script already scans `src/routes/` to generate the route tree. It should:

1. Detect `#[route(...)]` attributes on handler functions
2. Extract the certification configuration
3. Include config in the generated route registration

```rust
// Generated by build.rs in __route_tree.rs

// Route without attribute (uses default)
routes.insert("/about", RouteEntry {
    handler: routes::about::get,
    config: RouteConfig::default(),  // response_only
});

// Route with certification attribute
routes.insert("/api/user", RouteEntry {
    handler: routes::api::user::get_user,
    config: routes::api::user::__route_config(),  // Generated by macro
});
```

### Preset Implementations

Three named presets and one explicit form map between macro strings and `CertificationMode` constructors:

```rust
impl CertificationMode {
    /// Preset: "skip" — No certification
    pub fn skip() -> Self {
        CertificationMode::Skip
    }
    
    /// Preset: "response_only" — Response-only certification (default)
    pub fn response_only() -> Self {
        CertificationMode::ResponseOnly(ResponseOnlyConfig::default())
    }
    
    /// Preset: "authenticated" — Full certification with Authorization header.
    /// The most common reason to use Full mode is authenticated endpoints.
    pub fn authenticated() -> Self {
        CertificationMode::Full(
            FullConfig::builder()
                .with_request_headers(&["authorization"])
                .with_response_headers(&["content-type"])
                .build()
        )
    }
}
```

The macro maps preset strings to these constructors:

| Macro string | Constructor called |
|---|---|
| `"skip"` | `CertificationMode::skip()` |
| `"response_only"` | `CertificationMode::response_only()` |
| `"authenticated"` | `CertificationMode::authenticated()` |
| `custom(...)` | `CertificationMode::Full(FullConfig::builder()...build())` |

### RouteConfig Type

```rust
/// Configuration for a route, extracted from #[route] attribute.
#[derive(Clone, Debug)]
pub struct RouteConfig {
    /// Certification mode for this route.
    pub certification: CertificationMode,
    
    /// Optional TTL override for this route's cache.
    pub ttl: Option<Duration>,
    
    /// Additional headers to include in all responses.
    pub headers: Vec<HeaderField>,
}

impl Default for RouteConfig {
    fn default() -> Self {
        Self {
            certification: CertificationMode::response_only(),
            ttl: None,
            headers: vec![],
        }
    }
}
```

### Certification During Request Handling

When `http_request_update` handles a dynamic route:

```rust
fn handle_dynamic_route(
    path: &str,
    request: &HttpRequest,
    route_entry: &RouteEntry,
) -> HttpResponse<'static> {
    // Call handler to get response
    let response = (route_entry.handler)(request);
    
    // Certify based on route's configured mode
    match &route_entry.config.certification {
        CertificationMode::Skip => {
            // No certification, just cache
            cache_response(path, response, None)
        }
        CertificationMode::ResponseOnly(config) => {
            // Certify response only
            let cel = build_response_only_cel(config);
            let cert = HttpCertification::response_only(&cel, &response, None).unwrap();
            insert_and_cache(path, response, cert)
        }
        CertificationMode::Full(config) => {
            // Certify request + response
            let cel = build_full_cel(config);
            let cert = HttpCertification::full(&cel, request, &response, None).unwrap();
            insert_and_cache(path, response, cert)
        }
    }
}
```

### Why Proc Macro (and not other options)

**Rejected alternatives:**

1. **Config in mod.rs** — mod.rs is auto-generated, users can't edit it
2. **Separate config file** — Extra file to maintain, not discoverable
3. **Return type wrapper** — Changes function signature, breaks IDE completion
4. **Build script scans comments** — Fragile, not type-safe

**Proc macro advantages:**
- Attaches directly to the handler (where it logically belongs)
- Compile-time validation of config syntax
- IDE support (rust-analyzer can show completions for attribute values)
- Follows ecosystem conventions

### Proc Macro Crate Structure

```
ic-asset-router/
├── Cargo.toml
├── src/
│   └── lib.rs
├── macros/                    # Proc-macro subcrate
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs            # #[route] macro implementation
└── ...
```

```toml
# macros/Cargo.toml
[package]
name = "ic-asset-router-macros"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1.0"
quote = "1.0"
syn = { version = "2.0", features = ["full"] }
```

## Files to Create

- New crate: `macros/` — Proc-macro subcrate with `#[route]` attribute
- New file: `src/route_config.rs` — `RouteConfig` type and preset functions

## Files to Modify

- `Cargo.toml` — Add `macros` as a path dependency
- `src/lib.rs` — Re-export `#[route]` macro, export `RouteConfig`
- `src/build.rs` — Reference `__route_config()` functions in generated code
- `src/router.rs` — Store `RouteConfig` per route in route tree

## Acceptance Criteria

- [ ] `#[route]` proc-macro crate compiles successfully
- [ ] `#[route(certification = "skip")]` sets Skip mode
- [ ] `#[route(certification = "response_only")]` sets ResponseOnly mode (same as default)
- [ ] `#[route(certification = "authenticated")]` sets Full mode with Authorization header
- [ ] `#[route(certification = custom(...))]` allows custom Full configuration
- [ ] Routes without `#[route]` attribute default to ResponseOnly mode
- [ ] Build script references generated `__route_config()` functions
- [ ] Route tree stores and uses per-route certification configuration
- [ ] Full certification has access to original request for certification
- [ ] Handler signature unchanged (no return type wrapper)
- [ ] IDE completion works for attribute values
- [ ] Examples demonstrate different certification presets
- [ ] Documentation explains when to use each preset
