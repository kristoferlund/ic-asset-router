# 8.3 — Deduplicate Router and Asset Router Internals

**Phase:** 8 — Code Quality & Robustness  
**Priority:** High  
**Effort:** Medium  
**Status:** Not started

## Problem

### Router: _insert and _insert_result are structural duplicates

`src/router.rs` has two methods — `_insert` (lines ~278-306) and `_insert_result` (lines ~308-324) — that are structurally identical. Both parse a path into segments, walk/create the trie, and insert into a map. The only difference is which `HashMap` they write to (`handlers` vs `result_handlers`). This is ~46 lines of duplicated trie traversal code.

### Asset Router: certify_asset and certify_dynamic_asset share 80%

`src/asset_router.rs` has `certify_asset` (~lines 459-540) and `certify_dynamic_asset` (~lines 542-625) that share ~80% of their body:
1. Build CEL expression
2. Build response headers
3. Create tree entry and insert
4. Build encodings map
5. Construct `CertifiedAsset`
6. Insert into `self.assets`
7. Register fallbacks and aliases

The only differences: `certify_asset` builds its own `HttpResponse` from raw bytes while `certify_dynamic_asset` takes one as input, and Full mode requires the request for certification.

## Objective

1. Extract shared trie traversal into a single method in the router.
2. Extract shared certification logic into a single internal method in the asset router.

## Specification

### 8.3.1 — Extract router trie traversal

Add a private method:

```rust
impl RouteNode {
    /// Walk (or create) the trie path for the given segments, returning
    /// a mutable reference to the terminal node.
    fn get_or_create_node(&mut self, path: &str) -> &mut RouteNode
}
```

Then `_insert` and `_insert_result` become:

```rust
fn _insert(&mut self, path: &str, method: Method, handler: HandlerFn) {
    let node = self.get_or_create_node(path);
    node.handlers.insert(method, handler);
}

fn _insert_result(&mut self, path: &str, method: Method, handler: HandlerResultFn) {
    let node = self.get_or_create_node(path);
    node.result_handlers.insert(method, handler);
}
```

### 8.3.2 — Extract asset router certification core

Add a private method:

```rust
impl AssetRouter {
    fn certify_inner(
        &mut self,
        path: &str,
        body: Vec<u8>,
        response_for_cert: Option<&HttpResponse>,
        request: Option<&HttpRequest>,
        config: AssetCertificationConfig,
    ) -> Result<(), String>
}
```

Where:
- `response_for_cert` is `Some` for `certify_dynamic_asset` (caller provides the response) and `None` for `certify_asset` (the method builds one from `body` + config headers).
- `request` is `Some` only for Full mode.

Both public methods delegate to `certify_inner`.

## Acceptance Criteria

- [ ] `_insert` and `_insert_result` each fit in ~5 lines (delegation only).
- [ ] `certify_asset` and `certify_dynamic_asset` each fit in ~15 lines (parameter setup + delegation).
- [ ] `get_or_create_node` is tested independently.
- [ ] All existing tests pass.
- [ ] `cargo check` and `cargo doc --no-deps` pass with no new warnings.

## Files Modified

- `src/router.rs` — extract `get_or_create_node`
- `src/asset_router.rs` — extract `certify_inner`
