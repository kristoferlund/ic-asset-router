# 8.2 — Eliminate Production Panics

**Phase:** 8 — Code Quality & Robustness  
**Priority:** High  
**Effort:** Small  
**Status:** Not started

## Problem

### ic_cdk::trap in certification path

`certify_dynamic_response_with_ttl` in `src/lib.rs` calls `ic_cdk::trap()` in three places when certification fails:

1. Missing request for Full mode (`lib.rs:~1132`)
2. `certify_dynamic_asset` error (`lib.rs:~1139`)
3. `certify_asset` error (`lib.rs:~1145`)

A trap in an update call burns cycles and returns an opaque reject to the caller. Since the handler has already produced a valid response, it would be safer to return that response uncertified and log the error. The next query call would trigger an upgrade attempt, which is recoverable. A trap is not.

### url_decode leaks memory

`url_decode` in `src/context.rs:309` uses `.leak()` on a `Vec<u8>` in the error path:

```rust
.unwrap_or_else(|e| String::from_utf8_lossy(e.as_bytes().to_vec().leak()))
```

This permanently leaks heap memory. On the IC, heap is limited and grows monotonically. A malicious actor could craft requests with invalid percent-encoded sequences to slowly exhaust canister memory.

## Objective

1. Replace all `ic_cdk::trap` calls in the certification path with graceful degradation (return the uncertified response + log the error).
2. Fix the `url_decode` memory leak.

## Specification

### 8.2.1 — Replace traps with graceful degradation

In `certify_dynamic_response_with_ttl`:

- If `request` is `None` for Full mode: log via `debug_log!`, return the response as-is (uncertified).
- If `certify_asset` or `certify_dynamic_asset` returns `Err`: log via `debug_log!`, return the response as-is.

The response will lack certification headers, causing the boundary node to reject it on the query path. The next request will trigger a fresh update call, which will retry certification. This is self-healing.

### 8.2.2 — Fix url_decode memory leak

Replace:

```rust
.unwrap_or_else(|e| String::from_utf8_lossy(e.as_bytes().to_vec().leak()))
```

With:

```rust
.unwrap_or_else(|e| std::borrow::Cow::Owned(String::from_utf8_lossy(e.as_bytes()).into_owned()))
```

### 8.2.3 — Audit for other unwrap/trap calls

Scan `src/` for remaining `unwrap()`, `expect()`, and `trap()` calls that could fire in production (excluding test code and build script code). Document any that are intentional (e.g., `unwrap` on infallible operations) vs. those that need fixing.

## Acceptance Criteria

- [ ] Zero `ic_cdk::trap` calls in `certify_dynamic_response_with_ttl` or any response-serving path.
- [ ] `url_decode` does not call `.leak()`.
- [ ] Existing tests pass with no regressions.
- [ ] New unit test: `url_decode` with invalid UTF-8 sequences returns a valid string without leaking.
- [ ] `cargo check` passes.

## Files Modified

- `src/lib.rs` — replace traps
- `src/context.rs` — fix `url_decode`
